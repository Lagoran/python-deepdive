# coding: utf-8
"""
Copyright (c) 2017 Cloudera, Inc. All rights reserved.

Certificate manager.
"""

# Multi-processing notes:
# This module presently only 3 supported methods:
# 1. Setup: This is to be called exactly once and before
#    anything else can be called. Thus, by definition, this
#    needn't be (or, is) multi-process safe.
# 2. gen_node_cert: This is the only method that needs to be, and, is
#    multi-process safe.
#    Dev note: there is precisely 1 step here -- when we ask
#    the internal CA to sign the cert -- that can potentially
#    cause a problem. That is protected by acquiring an flock()
#    on a file in the CM-CA dir.
# 3. export_ca_cert: Read only call. Reads a file that is written
#    during setup and never changes. Hence there are no multi-processing
#    issues.
#
# Please note that this leaves out all the UNsupported interfaces
# that can be accessed via the --dev flag. These routines are NOT
# multi-process safe. So beware.

# pylint: disable=too-many-lines,too-many-public-methods,too-many-statements
# pylint: disable=too-many-instance-attributes,import-error, fixme
# pylint: disable=line-too-long,bad-continuation,bare-except,broad-except,invalid-name,
# pylint: disable=missing-docstring,too-many-branches,too-many-lines

import click
import logging
import os
import stat
import sys
import shutil
from subprocess import Popen, PIPE, STDOUT
import argparse
import tarfile
import StringIO
from cmf.util.config import Config, ConfigItem
import textwrap
import ConfigParser
import socket
import string
import re
from datetime import datetime, timedelta
import random
import hashlib
import tempfile
import cmf.util
import contextlib
import fcntl
from cmf.logging import setup_rolling_logging
from getpass import getpass
from cmf.util.os_ops import OSOps
import hmac
import json
import time

DATE_FORMAT = '%d/%b/%Y %H:%M:%S %z'
LOG = logging.getLogger()

# There are 2 sets of TLS creds:
# 1. For TLS connections where both endpoints can only be inside the cluster.
#    This set is called 'IN_CLUSTER'
# 2. For TLS connections where at least one endpoint could potentially be
#    anywhere. E.g. Hue server accepts connections from any browser that can
#    reach it. Hue needs to reach out to a corporate LDAP server.
#    This set is called 'GLOBAL'
IN_CLUSTER_TLS_SET='IN_CLUSTER'
GLOBAL_TLS_SET='GLOBAL'

# Each set of TLS creds has 2 types in which the creds are stored.
PEM_TLS_TYPE='PEM' # Used for TLS creds provided to openssl based code
JKS_TLS_TYPE='JKS' # Used for TLS creds provided to java based code

# For each type of TLS creds, we have 2 conceptual entities.
# 1. Entities that relate to 'who-we-trust'.This contains certificates of
#    CAs we trust.
# 2. Entities that relate to proving 'who-I-am'. This contains crypto keys
#    and certificates that certify these keys
TRUST_ENTITY="TRUST"
PROOF_ENTITY="KEYS"

# The default location of the certmanager directory
DEFAULT_CERTMANAGER_ROOT_DIR=\
        "/var/lib/cloudera-scm-server/certmanager"

# The name of the file that stores the config file
CONFIG_FILE_NAME="frozen_config.ini"

# Name of directory storing passwords for the certmanager
CERTMANAGER_PASSWORDS_DIR_NAME="private"
# Name of the directory storing the internal CA
CMCA_DIR_NAME="CMCA"
# Name of directory root storing host-related creds generated by, or provided
# to the certmanager
HOST_KEYSTORE_DIR_NAME="hosts-key-store"
# The name of the directory that stores all the trust info manged by the
# certmanger
TRUSTSTORE_DIR_NAME="trust-store"

# Filenames for the passwords
IN_CLUSTER_TRUSTSTORE_PASSWORD_FILE_NAME=".in_cluster_truststore_password"
IN_CLUSTER_KEY_PASSWORD_FILE_NAME=".in_cluster_key_password"
GLOBAL_TRUSTSTORE_PASSWORD_FILE_NAME=".global_truststore_password"
GLOBAL_KEY_PASSWORD_FILE_NAME=".global_key_password"

# File names for the CA keys
CA_CSR_FILE_NAME="ca_csr.pem"
CA_KEY_FILE_NAME="ca_key.pem"
CA_PASSWORD_FILE_NAME=".ca_key_password"

HOST_KEY_FILE_NAME = "cm-auto-host_key.pem"
HOST_CSR_FILE_NAME = "host.csr"
HOST_CERT_CHAIN_FILE_NAME = "cm-auto-host_cert_chain.pem"
HOST_KEY_PW_FILE_NAME = "cm-auto-host_key.pw"
HOST_KEYSTORE_FILE_NAME = "cm-auto-host_keystore.jks"
HOST_KEY_CERT_CHAIN_FILE_NAME = "cm-auto-host_key_cert_chain.pem"
HOST_PKCS12_FILE_NAME = "host.p12"
HOST_CSR_MARKER_FILE_NAME = ".stop_at_csr.marker"

# File names for in_cluster files
IN_CLUSTER_CA_CERT_FILE_NAME="cm-auto-in_cluster_ca_cert.pem"
IN_CLUSTER_TRUSTSTORE_FILE_NAME="cm-auto-in_cluster_truststore.jks"

# File names for 'global' truststore files
GLOBAL_CA_CERT_FILE_NAME="cm-auto-global_cacerts.pem"
GLOBAL_TRUSTSTORE_FILE_NAME="cm-auto-global_truststore.jks"

# File name for token signing key
TOKEN_KEY_PASSWORD_FILE_NAME = ".token_key_password"

# File to lockf()
CMCA_SIGNING_LOCK_FILE=".cm_ca.signing.lock"

# v3 extentions for X509 certs
CA_CERT_KEYUSAGE="keyCertSign"
HOST_CERT_KEYUSAGE="digitalSignature, keyEncipherment, keyAgreement"
HOST_CERT_EXT_KEYUSAGE="serverAuth, clientAuth"

# Just over 2^256 bits, given our character set of [a-zA-Z0-9]
PASSWORD_LEN=43
DEFAULT_CMCA_CERTIFICATE_DURATION_DAYS=5*365
DEFAULT_HOST_CERTIFICATE_DURATION_DAYS=365
DEFAULT_CMCA_CERT_EXPIRATION_DATETIME=(
    datetime.utcnow() + timedelta(DEFAULT_CMCA_CERTIFICATE_DURATION_DAYS)
  ).strftime('%y%m%d')
DEFAULT_HOST_CERT_EXPIRATION_DATETIME=(
        datetime.utcnow() + timedelta(DEFAULT_HOST_CERTIFICATE_DURATION_DAYS)
).strftime('%y%m%d')

# Default directory and file locations:
# The default location for the file that store CM defaults
DEFAULT_CM_DEFAULTS_FILE="/etc/default/cloudera-scm-server"
# The default location of the dir that stores the agent's certs
DEFAULT_AGENT_CERTS_DIR="/var/lib/cloudera-scm-agent/agent-cert"
# The default location of the agent's config file
DEFAULT_AGENT_CONFIG_FILE="/etc/cloudera-scm-agent/config.ini"
# The default location of the log file
DEFAULT_LOG_FILE="/var/log/cloudera-scm-agent/certmanager.log"

# These environment variables override the keystore/truststore passwords
# The default is a randomly-generated string
KEYSTORE_PASSWORD_ENV = "AUTO_TLS_KEYSTORE_PASSWORD"
TRUSTSTORE_PASSWORD_ENV = "AUTO_TLS_TRUSTSTORE_PASSWORD"


# This is the template used to generate CSRs. It contains a bunch of
# attributes that are usually ignored by CAs. We put it in because:
#  1) Our internal CA doesn't ignore it -- when generating a cert,
#     it copies the attributes over from the CSR. Our CA could just
#     as easily have ignored the CSRs attributes and put the desired
#     attributes directly into the cert (since we generate the CSR, and
#     we sign the cert ourselves). However, we put the attributes in
#     the CSR because:
#  2) Even when using an external CA, the attributes in the CSR can
#     help the hadoop or infosec admins understand what the system desires
#     in the eventual certificate.
# The attributes in question are:
# o Subject Name
# o X509v3 extensions
# I haven't been able to figure out how to get rid of the
# req_distinguished_name section even though I don't need it. An, it must be
# non-empty or openssl complains!
OPENSSL_REQ_TEMPLATE = """
[ req ]
distinguished_name  = req_distinguished_name
string_mask         = utf8only

[ req_distinguished_name ]
countryName                     = Country Name
countryName_default             = XX

[ req_ext ]
keyUsage=critical, {keyUsage}
{extendedKeyUsage}
{subjectAltNames}
"""

# The openssl CA configuration file. This will be generated one time,
# using the template below and used for all future CA operations
OPENSSL_CNF_FILE_NAME="openssl.cnf"
OPENSSL_CNF_TEMPLATE = """
# Auto generated. DO NOT EDIT.

RANDFILE                = {ca_priv_dir}/.rnd

[ ca ]
default_ca      = InternalCA           # The default ca section
prompt = no

[ InternalCA ]
db_dir          = {ca_db_dir}          # Where everything is kept
database        = $db_dir/index.txt    # database index file.
serial          = $db_dir/serial       # The current serial number
new_certs_dir   = $db_dir/newcerts     # default place for new certs.
certificate     = {ca_cert}            # The CA certificate
private_key     = {ca_key}             # The private key

default_md      = sha512               # use public key default MD
unique_subject  = no                   # Set to 'no' to allow creation of
                                       # several certificates with same subject
policy          = policy_any
preserve        = no                   # keep passed DN ordering
x509_extensions = v3_req               # The extentions to add to the cert
copy_extensions = copy

[ policy_any ]
commonName              = supplied

[ v3_non_ca ]
basicConstraints = critical, CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer

[ v3_ca ]
basicConstraints = critical, CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
"""

# We ask users to give us names in RFC4514 string format,
# but openssl requires RDNs in a DN to be separated by / (instead of
# , as in the RFC). openssl also requires subject names to be
# specified in the reverse order from the RFC.
# We thus have to process the string
# and convert it to the format that openssl needs)
# This means that we:
# o look for escaped characters and transfer them as-is
# o replace the RFC separator ',' with the openssl separator '/'
# o escape '/'
# o Remove leading spaces from the components (i.e. no spaces
#   after '/'
# o everything else stays as-is
# o Flip the RDN components
# Particularly, note that if input_delim is None (or ''),
# then the input is deemed to be only one component.
def convert_delim_to_openssl(s, input_delim=',', escape='\\',
                             output_delim='/'):
  """
  Convert an RFC4514 style DN (comma separated) to openssl style
  (/ separated). The order of RDNs in a DN is also reversed.
  :param s The utf-8 DN to convert
  :param input_delim The delimiter used in the input. If 'None' then
         the  input is assumed to be one component
  :param escape The escape character
  :param output_deliim The delimiter to be used in the output
  """
  rdns=[]
  component=[]
  itr = iter(s)
  for ch in itr:
    if ch == escape:
      try:
        # skip the next character; it has been escaped!
        component.append(escape)
        component.append(next(itr))
      except StopIteration:
          pass
    elif ch == input_delim:
      rdns += [''.join(component).lstrip()]
      component=[]
    elif ch in output_delim:
      component.append(escape)
      component.append(ch)
    else:
      component.append(ch)
  rdns+=[''.join(component).lstrip()]
  return output_delim.join(list(reversed(rdns)))


# This is a set of tests for convert_delim_to_openssl() above.
# To run them, do:
#   python -c "import cmf.tools.cert ; cmf.tools.cert.test_convert_delim_to_openssl()"
# The failure of a test will cause an assertion to blow up
def test_convert_delim_to_openssl():
  # Empty string results in no changes
  assert convert_delim_to_openssl('')==''

  # Simple, 1 component test
  assert convert_delim_to_openssl('foo')=='foo'

  # Two components
  assert convert_delim_to_openssl('foo,bar')=='bar/foo'

  # Three components
  assert convert_delim_to_openssl('foo,bar,baz')=='baz/bar/foo'

  # Two components, but one contains the output separator and will
  # need escaping
  assert convert_delim_to_openssl('foo/bar,baz')=='baz/foo\\/bar'

  # Two components, but one contains an escaped separator
  assert convert_delim_to_openssl('foo\\,bar,baz')=='baz/foo\\,bar'

  # ..Three components, because the escape for the separator is escaped
  assert convert_delim_to_openssl('foo\\\\,bar,baz')=='baz/bar/foo\\\\'

  # ..One more level of escaping
  assert convert_delim_to_openssl('foo\\\\\\,bar,baz')=='baz/foo\\\\\\,bar'

  # Custom input separator
  assert convert_delim_to_openssl('foo,barXbaz','X')=='baz/foo,bar'

  # Custom escape character
  assert convert_delim_to_openssl('foo\\,barX,baz',',','X')=='barX,baz/foo\\'

  # Custom output separator
  assert convert_delim_to_openssl('foo/bar,baz',',','\\','X')=='bazXfoo/bar'

  # Leading spaces before the components are removed
  assert convert_delim_to_openssl(' foo, bar, baz')=='baz/bar/foo'

  # .. including arbitrary number of spaces
  assert convert_delim_to_openssl('foo,    bar,baz')=='baz/bar/foo'

  # Trailing spaces are preserved
  assert convert_delim_to_openssl(' foo , bar , baz ')=='baz /bar /foo '

  # Internal spaces (including after esacped separator) are preserved
  assert convert_delim_to_openssl('foo, bar\\, baz')=='bar\\, baz/foo'

  # If input_delim is None, no component separation happens, but
  # escaping continues to be handled
  assert convert_delim_to_openssl('foo, /bar\\, baz', None)==\
            'foo, \\/bar\\, baz'


class CertConfig(Config):
  """
  Configuration schema for CertManager.

  """

  GENERAL="General"
  ca_type = ConfigItem(GENERAL, default="internal")
  trusted_ca_certs = ConfigItem(GENERAL)
  email_address = ConfigItem(GENERAL)
  subject_suffix = ConfigItem(GENERAL, "ST=CA, C=US")

  ca_key_algo = ConfigItem(GENERAL, default="rsa")
  ca_key_args = ConfigItem(GENERAL, default="3072")
  ca_sig_hash_algo = ConfigItem(GENERAL, default="sha256")
  ca_dn = ConfigItem(GENERAL)
  ca_expiration = ConfigItem(GENERAL,
                             default=DEFAULT_CMCA_CERT_EXPIRATION_DATETIME)
  host_expiration = ConfigItem(GENERAL,
                               default=DEFAULT_HOST_CERT_EXPIRATION_DATETIME)
  ca_name = ConfigItem(GENERAL,
                       default="SCM Local CA on %s" % socket.getfqdn())

  host_key_algo = ConfigItem(GENERAL, default="rsa")
  host_key_args = ConfigItem(GENERAL, default="3072")
  host_sig_hash_algo = ConfigItem(GENERAL, default="sha256")
  key_encryption_algo = ConfigItem(GENERAL, default="aes256")

  cm_defaults = ConfigItem(GENERAL, DEFAULT_CM_DEFAULTS_FILE)

  cm_user = ConfigItem(GENERAL, "cloudera-scm")
  cm_group = ConfigItem(GENERAL, "cloudera-scm")

  keytool = ConfigItem(GENERAL, lambda _, __ :
                         os.path.join(os.environ['JAVA_HOME'],"bin/keytool") \
                          if 'JAVA_HOME' in os.environ else None)
  keystore_type = ConfigItem(GENERAL, default="JKS")


def rchown(path, user, group):
  """
  chown user:group path/*
  """
  user, group = cmf.util.user_group_to_ids(user, group)
  paths = [path]
  for base, dirs, files in os.walk(path):
    paths.extend([os.path.join(base, d) for d in dirs])
    for f in files + [path]:
      f = os.path.join(base, f)
      try:
        os.chown(f, user, group)
      except OSError as e:
        LOG.warn("Chown error on %s: %s", f, e)

def gen_keypair(key_file, key_encryption_algo, password, key_algo, key_param):
  """
  Generate a public-private key pair.
  :param key_file Where to store the private key
  :param key_encryption_algo The algorithm used to encrypt the private key
  :param password The password to protect the private key with
  :param key_algo The private key algorithm to use (rsa, dsa, ec)
  :param key_param The parameter for the private key algorithm: # bits for
         rsa and dsa, curve name for 'ec'
  """

  if key_algo=="rsa":
    # Generate
    p = Popen(["openssl", "genrsa",
               "-out", key_file,
               "-%s" % key_encryption_algo,
               "-passout", "stdin",
               key_param], stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    p.stdin.write(password)
    p.stdin.close()
    p.wait()
    if p.returncode!=0:
      LOG.error("genrsa failed for %s. Exit code: %d Output:\n%s" %
                (key_file, p.returncode, "".join(p.stdout.readlines())))
      raise Exception("Could not generate RSA key")
  elif key_algo=="dsa":
    # Generate DSA key.
    # We generate the DSA param using dsaparam (which does not
    # encrypt the private key).Then, we pass the output to pkey
    # which can write out an encrypted private key, given the
    # password. The important thing is for all communication
    # (the unencrypted private key from dsaparam to pkey; and
    # the password given to pkey) to happen via pipes so they
    # are not available on disk, via command lines or the
    # environment.

    # Fire up the dsaparam process, have it send the key to stdout
    p1 = Popen(["openssl", "dsaparam",
                "-outform", "PEM",
                "-genkey",
                key_param], stdout=PIPE, stderr=PIPE)

    # Create a pipe for the password
    read_fd, write_fd = os.pipe()
    # Unlike traditional unix pipe use, the child process
    # (inside Popen()) will not close the write end of the
    # pipe. So we write to the pipe and close it ourselves
    # to avoid a hang. This, in theory, can create a hang
    # where the write buffer for the pipe is full, but we only
    # have a few bytes, so in practice it doesn't matter
    os.write(write_fd, password)
    os.close(write_fd)

    # Fire up the pkey process. Give it the password from
    # the pipe's read end. Give it stdin from dsaparam
    p2 = Popen(["openssl", "dsa",
                "-%s" % key_encryption_algo,
                "-passout", "fd:%d" % read_fd ,
                "-out", key_file,
                "-inform", "PEM",
                "-outform", "PEM"],
               stdin=p1.stdout, stdout=PIPE, stderr=STDOUT,
               close_fds=False)
    os.close(read_fd)
    p1.wait()
    p2.wait()
    if p1.returncode!=0 or p2.returncode!=0:
      LOG.error(("generating DSA key failed for %s. Exit codes: (%d|%d) " +
                "Stderr from dsaparam:\n%sOutput from pkey:\n%s") %
                 (key_file, p1.returncode, p2.returncode,
                  "".join(p1.stderr.readlines()),
                  "".join(p2.stdout.readlines())))
      raise Exception("Could not generate DSA key")
  elif key_algo=="ec":
    # Generate EC key. Same logic as in the DSA case above.
    p1 = Popen(["openssl", "ecparam",
                "-outform", "PEM",
                "-genkey",
                "-param_enc", "named_curve",
                "-name", key_param], stdout=PIPE, stderr=PIPE)

    read_fd, write_fd = os.pipe()
    os.write(write_fd, password)
    os.close(write_fd)
    p2 = Popen(["openssl", "ec",
                "-%s" % key_encryption_algo,
                "-passout", "fd:%d" % read_fd ,
                "-out", key_file,
                "-inform", "PEM",
                "-outform", "PEM"],
               stdin=p1.stdout, stdout=PIPE, stderr=STDOUT)
    os.close(read_fd)
    p1.wait()
    p2.wait()
    if p2.returncode!=0:
      LOG.error(("generating EC key failed for %s. Exit codes: (%d|%d) " +
                "Stderr from ecparam:\n%sOutput from pkey:\n%s") %
                (key_file, p1.returncode, p2.returncode,
                 "".join(p1.stderr.readlines()),
                 "".join(p2.stdout.readlines())))
      raise Exception("Could not generate EC key")
  else:
    raise ValueError("Invalid key_algo:%s" % key_algo)

  os.chmod(key_file, stat.S_IRUSR|stat.S_IWUSR)

def gen_csr(csr_file, key_file, password, subject,
            keyUsage, extendedKeyUsage, subjectAltNames=None):
  """
  Generate a CSR
  :param csr_file The file to write out the generated CSR to
  :param key_file The private key to use
  :param password The password for the private key
  The internal CA copies the following 4 fields verbatim from the CSR.
  Other CAs might not do so, but at least they know what we asked for.
  :param subject The Subject DN to add to the CSR
  :param keyUsage The X509v3 Extension 'keyUsage'. Must be set
  :param extendedKeyUsage The X509v3 Extension 'extendedKeyUsage'.
                          May be empty
  :param subjectAltNames The X509v3 Extension 'subjectAltName', if any,
                         to add to the CSR
  """

  # Convert extendedKeyUsage and subjectAltNames to openssl usable format
  if extendedKeyUsage:
    extendedKeyUsage="extendedKeyUsage = critical, %s" % extendedKeyUsage
  if not subjectAltNames:
    subjectAltNames=""
  else:
    subjectAltNames="subjectAltName=%s" % ", ".join(subjectAltNames)

  # Create the openssl req config file
  req_conf=OPENSSL_REQ_TEMPLATE.format(
                    keyUsage=keyUsage,
                    extendedKeyUsage=extendedKeyUsage,
                    subjectAltNames=subjectAltNames)

  # We have to send both the password, and the config file to openssl req
  # The config file could have been written to disk (nothing sensitive)
  # but that means we have to manage a temp file. We just send both over
  # pipes.
  read_fd, write_fd = os.pipe()
  os.write(write_fd, password)
  os.close(write_fd)
  req = Popen(["openssl", "req",
               "-new",
               "-key", key_file,
               "-passin", "fd:%d" % read_fd,
               "-out", csr_file,
               "-outform", "PEM",
               "-subj",
                  "/%s" % convert_delim_to_openssl(subject).encode('utf-8'),
               "-utf8",
               "-multivalue-rdn",
               "-reqexts", "req_ext",
               "-config", "/dev/fd/0"],
              stdin=PIPE, stdout=PIPE, stderr=STDOUT)
  os.close(read_fd)
  req.stdin.write(req_conf)
  req.stdin.close()
  req.wait()
  if req.returncode!=0:
    LOG.error("req failed for %s. Exit code: %d Output:\n%s" %
              (key_file, req.returncode, "".join(req.stdout.readlines())))
    raise Exception("Could not generate CSR")

def sign_cert(csr_file, cert_file, ca_dir, ca_password, sig_algo,
              endDate, trust_files, isCA=False, update_openssl_cnf=True):
  """
  Sign the given CSR using the internal CA. The internal CA is very
  promiscuous and will sign anything for anyone who has the password.
  The caller is supposed to make the CSR with care and fill in the
  following correctly (since they are copied verbatim from the CSR):
  1) Subject DN
  2) X509v3 Extension 'keyUsage'
  3) X509v3 Extension 'extendedKeyUsage'
  4) X509v3 Extension 'subjectAltName'
  :param csr_file The PEM file which contains the CSR
  :param cert_file The output PEM file containing the signed certificate
         (Contains the full chain)
  :param ca_dir The directory where the internal CA stores its files
  :param ca_password The password for the CA's private key
  :param sig_algo The hashing algorithm to use when signing
  :param endDate "YYYMMDD" format date for when certificate expires.
            Certificate expires at 23:59:59 on the given date at GMT time
  :param trust_files Map of truststore files
  :param isCA True if this is the root CA. False otherwise. Intermediate CAs
         are not supported.
  :param update_openssl_cnf Rewrite openssl.cnf with the current CMCA directory
  """
  if update_openssl_cnf:
    ca_private_dir = os.path.join(ca_dir, "private")
    ca_db_dir = os.path.join(ca_dir, "ca-db")

    ca_cert_file = trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
    ca_key_file = os.path.join(ca_private_dir, CA_KEY_FILE_NAME)
    ca_password_file = os.path.join(ca_private_dir, CA_PASSWORD_FILE_NAME)
    openssl_cnf_file = os.path.join(ca_dir, OPENSSL_CNF_FILE_NAME)

    # Create the openssl.cnf file
    with open(openssl_cnf_file, 'w') as conf_file:
      conf_file.write(OPENSSL_CNF_TEMPLATE.format(ca_db_dir=ca_db_dir,
                                                  ca_priv_dir=ca_private_dir,
                                                  ca_key=ca_key_file,
                                                  ca_cert=ca_cert_file))

    # Assign a random serial number
    with open(os.path.join(ca_db_dir, 'serial'), 'w') as f:
      f.write(generate_random_serial())


  ca = Popen( ["openssl", "ca",
               "-config", os.path.join(ca_dir, OPENSSL_CNF_FILE_NAME),
               "-extensions", "v3_ca" if isCA else "v3_non_ca",
               "-md", sig_algo,
               "-in", csr_file,
               "-out", cert_file,
               "-passin", "fd:0",
               "-enddate", "%s235959Z" % endDate,
               "-keyform", "PEM",
               "-notext",
               "-batch",
               "-utf8",
               "-preserveDN",
               "-multivalue-rdn"] +
               (["-selfsign"] if isCA else []),
               stdin=PIPE, stdout=PIPE, stderr=STDOUT)
  ca.stdin.write(ca_password)
  ca.stdin.close()
  ca.wait()
  if ca.returncode!=0:
    LOG.error("ca failed for %s. Exit code: %d Output:\n%s" %
              (csr_file, ca.returncode, "".join(ca.stdout.readlines())))
    raise Exception("Could not sign CSR")

def iterate_pem_certs(cert_bundle, skip_invalid_certs, process_func):
  """
  Helper function which splits a bundle containing PEM certificates into
  multiple files containing a single cert, and calls the process_func on each
  each file. Cleans up the generated files afterwards.
  """
  tmpdir = tempfile.mkdtemp()
  try:
    p = Popen(["awk",
               '/-----BEGIN (TRUSTED )?CERTIFICATE-----/ { dump=1 } '+
               'dump==1 {print > "%s/individual-" (1+n) ".pem"} ' % tmpdir +
               '/-----END (TRUSTED )?CERTIFICATE-----/ {n++; dump=0}',
               cert_bundle], stdout=PIPE, stderr=STDOUT)
    p.wait()
    if p.returncode!=0:
      LOG.error("Could not process %s file. Exit code: %d. "
                 "Output:\n%s" % (cert_bundle, p.returncode,
                                  "".join(p.stdout.readlines())))

    cert_index = 0
    for _, __, files in os.walk(tmpdir):
      for f in files:
        try:
          process_func(os.path.join(tmpdir, f), cert_index)
        except Exception as e:
          if skip_invalid_certs:
            LOG.error(e)
            LOG.info("Continuing because of command line option")
          else:
            raise e
        cert_index = cert_index + 1
  finally:
    shutil.rmtree(tmpdir)

def generate_truststore(keytool, truststore_file, truststore_password,
                        cert_file, keystore_type):
  """
  Generate a java trustore from the given CA certificate
  """
  def _import_cert(single_cert_file, cert_index):
    p = Popen( [ keytool, "-importcert",
                 "-noprompt",
                 "-keystore", truststore_file,
                 "-storetype", keystore_type,
                 "-alias", "CMRootCA-%s" % cert_index,
                 "-file", single_cert_file,
                 "-storepass:file", "/dev/fd/0"],
               stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    p.stdin.write(truststore_password)
    p.stdin.close()
    p.wait()
    if p.returncode!=0:
      LOG.error("keytool -importcert failed. Exit code: %d. Output:\n%s" %
                (p.returncode, "".join(p.stdout.readlines())))
      raise Exception("Could not create truststore")

  iterate_pem_certs(cert_file, False, _import_cert)

  # Truststore doesn't contain sensitive secrets. In particular, YARN jobs need
  # to be able to read it, so make it world-readable.
  os.chmod(truststore_file, 0o644)

# Generate a 'good' password
def generate_random_password(length=PASSWORD_LEN):
  password_chars = ( string.ascii_uppercase
      + string.ascii_lowercase
      + string.digits )
  password = ''.join(random.SystemRandom().choice(password_chars)\
                      for _ in range(length))
  return password

# Generate a (hex) serial number
def generate_random_serial(length=16):
  serial_chars = ( string.digits + "abcdef" )
  serial = ''.join(random.SystemRandom().choice(serial_chars)\
                   for _ in range(length))
  return serial

# Generates the name of a backup directory given an existing directory
def _make_backup_dir(base_dir):
  timestamp = datetime.now().strftime("%Y-%m-%d")
  random_suffix = generate_random_password(8)
  return "%s-backup-%s-%s" % (base_dir, timestamp, random_suffix)

def hex_str(byteArr):
  return ''.join(format(ord(x), '02x') for x in byteArr)

# (Sadly, the following comment and code will be visible to anyone
# who can read the python source code. Which is how we distribute the
# agent code)
# Obfuscated password format:
#  <magic-header> <version> <key-iv-generator> <encrypted-password-in-base64>
# For Version 1, the rules are:
#   use AES256/OFB mode, using:
#   key = sha512(<key-iv-generator>+OBFUSCATION_SECRET+"KEY")
#   iv = sha512(<key-iv-generator>+OBFUSCATION_SECRET+"IV")
# Since adding python dependencies for 5.11 is difficult, we perform the
# encryption / decryption using openssl. That's not ideal since we need
# to pass the key and iv on the commandline, but hey, this is obfuscation.
# In C6, we can revisit this and do the entire operation in Python itself.

# hex encoding of uft8 encoding of the
# â˜£(bio-hazard:U+2623), ðŸ’£(bomb:U+1F4A3) and â˜ (skull:U+2620) characters
OBFUSCATION_HEADER="e298a3f09f92a3e298a0"
OBFUSCATION_VERSION="1"
# hex encoding of uft8 encoding of the
# ðŸ™(folded hands:U+1F64F), ðŸ“¿(prayer beads:U+1F4FF) and
# ðŸ¤ž(fingers crossed:U+1F91E) characters
OBFUSCATION_SECRET="f09f998ff09f93bff09fa49e"

def write_obfuscated_password(pwfile, password):
  with os.fdopen(os.open(pwfile, os.O_CREAT|os.O_WRONLY, 0o600), "w") as f:
    f.write("%s " % OBFUSCATION_HEADER)
    f.write("%s " % OBFUSCATION_VERSION)
    random = generate_random_password()
    f.write("%s " % random)
    m=hashlib.sha512()
    m.update(random)
    m.update(OBFUSCATION_SECRET)
    m2 = m.copy()
    m.update("IV")
    iv = m.digest()[:16] # 128 bits for IV
    m2.update("KEY")
    key = m2.digest()[:32] # 256 bits for key
    p = Popen(["openssl", "enc", "-e", "-aes-256-ofb",
               "-K", hex_str(key),
               "-iv", hex_str(iv),
               "-a", "-A",
               ],
              stdin=PIPE, stdout=PIPE, stderr=PIPE)
    stdout, stderr = p.communicate(password)
    if p.returncode!=0:
      LOG.error("openssl enc -e failed for %s. Exit code %s. Stderr:\n%s" %
                (pwfile, p.returncode, stderr))
      raise RuntimeError("Could not encrypt")
    f.write(stdout)

def read_obfuscated_password(pwfile):
  with open(pwfile, "r") as f:
    hdr, version, random, enc = f.readline().split()
  if hdr!=OBFUSCATION_HEADER:
    raise RuntimeError("%s in not a valid password file" % pwfile)
  if version!=OBFUSCATION_VERSION:
    raise RuntimeError("%s is from the future" % pwfile)
  m=hashlib.sha512()
  m.update(random)
  m.update(OBFUSCATION_SECRET)
  m2 = m.copy()
  m.update("IV")
  iv = m.digest()[:16] # 128 bits for IV
  m2.update("KEY")
  key = m2.digest()[:32] # 256 bits for key
  p = Popen(["openssl", "enc", "-d", "-aes-256-ofb",
             "-K", hex_str(key),
             "-iv", hex_str(iv),
             "-a", "-A",
             ],
            stdin=PIPE, stdout=PIPE, stderr=PIPE)
  stdout, stderr = p.communicate(enc)
  if p.returncode!=0:
    LOG.error("openssl enc -d failed for %s. Exit code %s. Stderr:\n%s" %
              (pwfile, p.returncode, stderr))
    raise RuntimeError("Could not encrypt")
  return stdout

def read_clear_password_from_fd(fd):
  """
  In some cases, we will be given a password on a file descriptor.
  Read the password
  """
  with os.fdopen(fd, 'r') as f:
    return f.read().strip()

def gen_subject(subject_suffix, commonName, shortName=None):
  """
  Generate a certificate subject from a CertConfig and names. If the commonName
  is too long, use the shortName instead. If shortName not specified, or even
  that is too long, then using a truncated version of commonName (truncating
  somewhere from the middle, as sometimes the end keeps the value unique, e.g.
  numbering of hostnames, or maybe date appended to other values).
  """
  if not subject_suffix:
    raise ValueError('subject_suffix cannot be empty')

  if not commonName:
    raise Exception("Need a commonName")

  # User better give a sane commonName or we get an error from openssl
  out = convert_delim_to_openssl(commonName.decode('utf-8'), None)
  if shortName:
    sn_out = convert_delim_to_openssl(shortName.decode('utf-8'), None)
  else:
    sn_out = ""

  if len(out) > 64:
    # If shortName alone does not exceed length limit, then use it
    if shortName and len(sn_out) <= 64:
      LOG.info("Subject '%s' is too long, using shortname '%s' instead" %
               (out, sn_out))
      return gen_subject(subject_suffix, shortName)

    # We tried everything else, but can't avoid truncating commonName
    truncated = "%s~~~%s" % (out[:40], out[-21:])
    LOG.info("Subject '%s' is too long, using truncated version '%s' instead" %
             (out, truncated))
    out = truncated

  return "commonName=%s, %s" % (out, subject_suffix.decode('utf-8'))

def gen_altNames(hostname, email_address, altnames):
  """
  Given the hostname and an option array of altnames entries,
  generates and array of normalized altNames
  - Performs (basic) sanity checks on hostname and altnames
  - Processes the given altnames, adding any DNS:,IP: or email: prefixes
    if needed
  - Adds the hostname itself as a subjectAltName
  :param hostname  The hostname (or IP) we are generating the cert for.
         The 'hostname' must be a valid DNS name, IPv4 address or IPv6
         address. We strongly recommend that this be the FQDN that is used
         by CM to identify this host.
  :param email_address If given, this email address is added to the
         subjectAltNames
  :param altnames The additional subject alt names to add to the certificate.
         The hostname is added automatically.
         Multiple alternate names may be specified. Each must be in one of
         the following
         formats:
         1) DNS:<valid-dns-name>
         2) IP:<valid-IPv4-address>
         3) email:<valid-email-address>
  """
  # Very basic Regexes for very basic sanity checks

  # Doesn't validate that the lengths are correct
  DNS_REGEX=(r"^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*"
             r"([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$")

  # Only validates grammar. E.g. 999.0.0.0 is deemed valid, as is 0.0.0.0
  IPV4_REGEX=r"^([0-9]{1,3}\.){3}[0-9]{1,3}$"
  # CM does not support IPv6

  # Does not enforce all of RFC5322 rules.
  # Doesn't validate quoting rules.
  # Does not allow valid UTF8 characters. But hard to write a proper
  # regex for that.
  # python has a validate_email module, but we can't add new dependencies
  # in 5.11
  EMAIL_REGEX=(r"(^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+"
               r"@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)")

  altNames=[]
  for name in altnames:
    if not name.startswith("DNS:") and \
       not name.startswith("email:") and \
       not name.startswith("IP:"):
      raise Exception("Altname %s is does not have an accepted prefix."
                      % name)
    else:
      typ, value = name.split(':', 1)
      if "DNS"==typ and not re.search(DNS_REGEX, value):
        raise Exception("%s is not a valid DNS name" % value)
      if "IP"==typ and not re.search(IPV4_REGEX, value):
        raise Exception("%s is not a valid IPv4 Address" % value)
      if "email"==typ and not re.search(EMAIL_REGEX, value):
        raise Exception("%s is not a valid IPv4 Address" % value)
      altNames += [ name ]

  if re.search(IPV4_REGEX,hostname) :
    altNames += [ "IP:%s" % hostname ]
  elif re.search(DNS_REGEX, hostname, re.IGNORECASE):
    altNames += [ "DNS:%s" % hostname ]
  else:
    raise ValueError("Invalid value for hostname. Does not look like a"
                     " DNS name or IPv4 address. Got: %s" % hostname)

  if email_address:
    if not re.search(EMAIL_REGEX, email_address):
      raise Exception("%s is not a valid email address" % email_address)
    altNames += [ "email:%s" % email_address ]

  return altNames

def generate_host_csr(host_csr_file, host_key_file, key_algo, key_param,
                      key_encryption_algo, password,
                      subject, subjectAltNames=None):
  """
  Generate a CSR for a host.
  :param host_csr_file The file where we write the generated CSR
  :param host_key_file The file where we write the generated private key
                       for the host
  :param key_algo The asymmetric key algo to use
  :param key_param The paramter to the key algo (# bits, curve name, etc.)
  :param key_encryption_algo The algo to use to encrypt the private key
  :param password The password for the encryption
  :param subject The subject DN in the CSR
  :param subjectAltNames The subject alternate names to use in the
                         certificate
  """
  gen_keypair(host_key_file, key_encryption_algo, password,
              key_algo, key_param)
  gen_csr(host_csr_file, host_key_file, password, subject,
          HOST_CERT_KEYUSAGE,
          HOST_CERT_EXT_KEYUSAGE, subjectAltNames)

def sign_host_csr_with_internal_ca(host_cert_file, host_csr_file, ca_dir,
                                   sig_algo, expiration, trust_files):
  """
  Use the internal CA to sign the given host's CSR
  :param host_cert_file The file where we write the generated
         cert to (in PEM format). Contains the full chain.
  :param host_csr_file The input CSR
  :param ca_dir The directory that is the root of the internal CA
  :param sig_algo The hashing algo to use in the signature
  :param expiration The expiration date on the certificate
  :param trust_files Map of truststore files
  """
  if (not os.path.exists(ca_dir) or
      not os.path.isdir(ca_dir)):
    # This shows that either, we are not using the internal CA, or some
    # error occurred in initializing it or subsequently (e.g. admin
    # deleted dir)
    raise Exception("Missing dir %s. Please ensure that you have initialized"
                    " the 'internal' CA." % ca_dir)
  ca_private_dir = os.path.join(ca_dir, "private")
  ca_password_file = os.path.join(ca_private_dir, CA_PASSWORD_FILE_NAME)
  ca_password = read_obfuscated_password(ca_password_file)
  sign_cert(host_csr_file, host_cert_file, ca_dir, ca_password,
            sig_algo, expiration, trust_files, False)


def is_path_accessible_for_user(path, uid, gid):
  """
  checks if the given path (file or dir) is reachable for the user
  given by uid and gid. It doesn't check if the file / dir is readable
  or writeable, just that it is reachable. Thus, it is really checking
  for the permissions on the intermediate directories in the path.

  Returns True if path is accessible, False if it is not.

  Do NOT call this in a multi-threaded program, as it adjusts the process'
  effective user and group ids temporarily.
  """

  current_euid = os.geteuid()
  current_egid = os.getegid()
  try:
    os.setegid(gid)
    os.seteuid(uid)
    if not os.path.exists(path):
      return False
    return True
  finally:
    os.seteuid(current_euid)
    os.setegid(current_egid)


def compare_digest(digest1, digest2):
  """
  Constant-time comparison of two strings. We really want to use
  hmac.compare_digest here, but that's only available in Python 2.7.7+.
  """
  if len(digest1) != len(digest2):
    return False

  result = True
  for d1, d2 in zip(digest1, digest2):
    result &= (d1 == d2)

  return result


class CertManager(object):
  """
  This is the Certmanager object, that abstracts the state and operations of the
  certificate manager.

  This is NOT multi-thread safe.
  """

  def __init__(self, location):
    self.certmanager_dir=location
    config_file = os.path.join(self.certmanager_dir, CONFIG_FILE_NAME)

    if os.path.exists(config_file):
      self.config=config_file
      self.cfg = CertConfig.make_config(config_file, None, CertConfig.GENERAL)
      # Validate the CA type
      if "internal" != self.cfg.ca_type:
        raise ValueError("Only 'internal' CA types supported for now. Got '%s'"
                         " in ca_type" % self.cfg.ca_type)
      self.is_internal_ca = True

    self.cmca_dir = os.path.join(self.certmanager_dir, CMCA_DIR_NAME)
    self.truststore_dir = os.path.join(self.certmanager_dir,
                                       TRUSTSTORE_DIR_NAME)
    self.trust_files = {
      GLOBAL_TLS_SET : {
        PEM_TLS_TYPE : os.path.join(self.truststore_dir,
                                    GLOBAL_CA_CERT_FILE_NAME),
        JKS_TLS_TYPE : os.path.join(self.truststore_dir,
                                    GLOBAL_TRUSTSTORE_FILE_NAME),
        },
      IN_CLUSTER_TLS_SET : {
        PEM_TLS_TYPE : os.path.join(self.truststore_dir,
                                    IN_CLUSTER_CA_CERT_FILE_NAME),
        JKS_TLS_TYPE : os.path.join(self.truststore_dir,
                                    IN_CLUSTER_TRUSTSTORE_FILE_NAME),
        },
                        }
    self.certmanager_passwords_dir = os.path.join(self.certmanager_dir,
                                        CERTMANAGER_PASSWORDS_DIR_NAME)
    self.password_files = {
      GLOBAL_TLS_SET : {
        TRUST_ENTITY: os.path.join(self.certmanager_passwords_dir,
                                   GLOBAL_TRUSTSTORE_PASSWORD_FILE_NAME),
        PROOF_ENTITY: os.path.join(self.certmanager_passwords_dir,
                                   GLOBAL_KEY_PASSWORD_FILE_NAME),
        },
      IN_CLUSTER_TLS_SET : {
        TRUST_ENTITY: os.path.join(self.certmanager_passwords_dir,
                                   IN_CLUSTER_TRUSTSTORE_PASSWORD_FILE_NAME),
        PROOF_ENTITY: os.path.join(self.certmanager_passwords_dir,
                                   IN_CLUSTER_KEY_PASSWORD_FILE_NAME),
        },
                        }
    # The dir that is the root of all the hosts' key-store, or
    # proof-related files
    self.hosts_keystores_dir=os.path.join(self.certmanager_dir,
                                          HOST_KEYSTORE_DIR_NAME)

    # Password file for cert request token password
    self.token_password_file = os.path.join(self.certmanager_dir,
                                            CERTMANAGER_PASSWORDS_DIR_NAME,
                                            TOKEN_KEY_PASSWORD_FILE_NAME)

    honor_users_and_groups = True
    if os.getuid() != 0:
      LOG.info("certmanager not running as root")
      honor_users_and_groups = False

    self.os_ops = OSOps(honor_users_and_groups)

  def makedirs(self, path, mode=0o700):
    self.os_ops.mkabsdir(path, self.cfg.cm_user, self.cfg.cm_group, mode)

  def chown_tree(self, path):
    """
    chown -R <cm_user>:<cm_group> path
    """
    rchown(path, self.cfg.cm_user, self.cfg.cm_group)

  def check_user_access(self, path):
    """
    This script is run by the sysadmin/root of the box to generate stuff (e.g.
    certs, config files). It is then invoked as the 'cloudera-scm' user (or
    whatever non-default value was used to configure) to use these files
    during host cert generation. This routine checks that the paths we are
    generating will be accessible by the cloudera-scm (or configured) user.

    When, we generate paths, we do so with the right mode and chown them
    appropriately. However, say the path we are creating is /a/b/c/d/e.
    /a/b/c exists. We will create d/e relative to /a/b/c. We will create d with
    mode 0755. We will chown e to the cloudera-scm user. However, this doesn't
    guarantee that /a/b/c is accessible by cloudera-scm user since we didn't
    create it! (e.g. b could be root owned with 0700). root will not have a
    problem creating this path, but cloudera-scm will not be able to use it
    to generate certs. We don't want to go chown/chmod /a/b/c since we don't
    know what else it might contain.

    Hence the need for this routine. It performs the check described above
    and throws an exception if it detects a potential problem with a warning
    to the user to fix perms / ownership / choose a different path.

    Do not call this routine in a multi-threaded program.
    """

    uid, gid = cmf.util.user_group_to_ids(self.cfg.cm_user, self.cfg.cm_group)
    if not is_path_accessible_for_user(path, uid, gid):
      LOG.error("User %s cannot access path %s because the permissions along "
                "the path are too restrictive" % (self.cfg.cm_user, path))
      raise Exception("Path permissions not correct")

  def setup_config(self, config, override, chown_logfile):
    # Generate the necessary top-level directories for the certmanager
    if not os.path.isdir(self.certmanager_dir):
      # We have not loaded the config yet, so we cannot use self.makedirs()
      self.os_ops.mkabsdir(self.certmanager_dir, mode=0o755)

    # Get the current config, with overrides
    self.cfg = CertConfig.make_config(config, override, CertConfig.GENERAL)

    # Get the new location of the config file we are going to use
    self.config = os.path.join(self.certmanager_dir, CONFIG_FILE_NAME)

    # Validate the CA type
    if "internal"!=self.cfg.ca_type:
      raise ValueError("Only 'internal' CA types supported for now. Got '%s'"
                       " in ca_type" % self.cfg.ca_type)
    self.is_internal_ca = True

    # Validate the keytool
    if not self.cfg.keytool:
      # If the keytool arg is no present in the config file, it would
      # have been created from JAVA_HOME, if that is present in the env
      raise Exception("No keytool found. Set JAVA_HOME or set 'keytool'"
                      " config param")
    if not(os.path.exists(self.cfg.keytool)):
      raise Exception("Cannot identify a valid keytool: %s"
                      % self.cfg.keytool)

    # Freeze and dump the config
    out_cfg = ConfigParser.SafeConfigParser()

    for (section, values) in self.cfg.value_map().iteritems():
      if not out_cfg.has_section(section):
        out_cfg.add_section(section)

      for (k, v) in values.iteritems():
        if v is not None:
          out_cfg.set(section, k, str(v))

    if not out_cfg.has_section(CertConfig.GENERAL):
      out_cfg.add_section(CertConfig.GENERAL)

    out_cfg.set(CertConfig.GENERAL, "keytool", self.cfg.keytool)
    with open(self.config,"w") as f:
      out_cfg.write(f)

    # Certmanager commands may be run as cloudera-scm. Chown the log file so that
    # cloudera-scm has write permission to it
    if chown_logfile:
      self.os_ops.set_path_metadata(DEFAULT_LOG_FILE, self.cfg.cm_user,
                                    self.cfg.cm_group, mode=0o644)

  def init_certmanager(self, config, override, rotate, check_access):
    """
    Initialize the directory structure for the certmanager
    """

    # Don't overwrite, since that could cause the cluster to stop functioning
    if (os.path.exists(self.certmanager_dir) and
        len(os.listdir(self.certmanager_dir)) > 0):
      if rotate:
        backup_dir = _make_backup_dir(self.certmanager_dir)
        LOG.info("Directory %s already exists. Creating a new CA. The old CA"
                 " will be backed up to %s." % (self.certmanager_dir,
                                                backup_dir))
        os.rename(self.certmanager_dir, backup_dir)
        return self.init_certmanager(config, override, False, check_access)
      else:
        raise Exception("It seems that a CA setup has already been created.")

    # Read and write out config
    self.setup_config(config, override, check_access)

    # Check that this path will be accessbile by the SCM server
    if check_access:
      try:
        self.check_user_access(self.certmanager_dir)
      except:
        # Cleanup, as much as we can
        shutil.rmtree(self.certmanager_dir, True)
        raise

    os.chmod(self.certmanager_dir, 0o700)
    self.makedirs(self.certmanager_passwords_dir)
    self.makedirs(self.truststore_dir, mode=0o755)
    self.makedirs(self.hosts_keystores_dir)

    # If keystore/truststore password is passed in the environment, use that
    # instead of generating random passwords
    keystore_password = None
    if KEYSTORE_PASSWORD_ENV in os.environ:
      keystore_password = os.environ[KEYSTORE_PASSWORD_ENV]
    if not keystore_password or len(keystore_password) == 0:
      keystore_password = generate_random_password()

    truststore_password = None
    if TRUSTSTORE_PASSWORD_ENV in os.environ:
      truststore_password = os.environ[TRUSTSTORE_PASSWORD_ENV]
    if not truststore_password or len(truststore_password) == 0:
      truststore_password = generate_random_password()

    # Write out all the password files.
    for _,tls_set in self.password_files.items():
      write_obfuscated_password(tls_set[PROOF_ENTITY], keystore_password)
      write_obfuscated_password(tls_set[TRUST_ENTITY], truststore_password)

  def init_internal_ca(self, config, override, rotate, stop_at_csr, check_access):
    """
    Initialize the internal CA using the config params.

    Can only be called when the CA type is internal. Do not
    call more than once unless rotate is given.
    """

    self.init_certmanager(config, override, rotate, check_access)

    assert self.is_internal_ca

    cfg = self.cfg
    key_algo = cfg.ca_key_algo.lower()
    key_encryption_algo = cfg.key_encryption_algo.lower()
    key_param = cfg.ca_key_args
    sig_algo = cfg.ca_sig_hash_algo.lower()
    expiration = cfg.ca_expiration

    # Do some basic validation. openssl may still find the values invalid,
    # but we need to see that things aren't grossly incorrect and give
    # a friendlier message than openssl will
    if key_algo not in set(["rsa", "dsa", "ec"]):
      raise ValueError("Got an invalid value for ca_key_algo: %s" % key_algo)
    if key_algo == "rsa" or key_algo == "dsa":
      try:
        int(key_param)
      except ValueError:
        raise ValueError("Expected an integer (# of bits), but got an invalid"
                         +" value for ca_key_args: %s" % key_param)
    if sig_algo not in set(["md5", "mdc2", "sha1", "sha256", "sha512"]):
      raise ValueError("Got an invalid value for ca_sig_hash_algo: %s"
                       % sig_algo)
    try:
      datetime.strptime(expiration,'%y%m%d')
    except ValueError:
      raise ValueError("Expected a valid date for ca_expiration in YYMMDD"
                       " format. Got: %s" % expiration)
    if key_encryption_algo not in set(["des", "des3", "aes128", "aes256"]):
      raise ValueError("Got an invalid value for key_encryption_algo: %s"
                       % key_encryption_algo)

    # Create the subject DN. If given explicitly, use that
    if cfg.ca_dn is None:
      # Not given. Generate from other params
      subject = gen_subject(cfg.subject_suffix, cfg.ca_name)
    else:
      subject = cfg.ca_dn.decode('utf-8')

    ca_dir = self.cmca_dir
    ca_private_dir = os.path.join(ca_dir, "private")
    ca_db_dir = os.path.join(ca_dir, "ca-db")

    ca_cert_file = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
    ca_key_file = os.path.join(ca_private_dir, CA_KEY_FILE_NAME)
    ca_password_file = os.path.join(ca_private_dir, CA_PASSWORD_FILE_NAME)
    openssl_cnf_file = os.path.join(ca_dir, OPENSSL_CNF_FILE_NAME)

    # Create dirs
    self.makedirs(ca_dir)
    self.makedirs(ca_db_dir)
    self.makedirs(ca_private_dir)
    self.makedirs(os.path.join(ca_db_dir, 'newcerts'))

    # Create required files for the openssl CA to keep its state
    open(os.path.join(ca_db_dir, 'index.txt'), 'w').close()
    with open(os.path.join(ca_db_dir, 'index.txt.attr'), 'w') as f:
      f.write('unique_subject = no')
    with open(os.path.join(ca_db_dir, 'serial'), 'w') as f:
      f.write(generate_random_serial())

    # Create the openssl.cnf file
    with open(openssl_cnf_file, 'w') as conf_file:
      conf_file.write(OPENSSL_CNF_TEMPLATE.format(ca_db_dir=ca_db_dir,
                                                  ca_priv_dir=ca_private_dir,
                                                  ca_key=ca_key_file,
                                                  ca_cert=ca_cert_file))

    password = generate_random_password()

    # Now, perform the necessary steps
    gen_keypair(ca_key_file, key_encryption_algo, password,
                key_algo, key_param)
    csr_file = os.path.join(ca_private_dir, CA_CSR_FILE_NAME)
    write_obfuscated_password(ca_password_file, password)
    gen_csr(csr_file, ca_key_file, password, subject, CA_CERT_KEYUSAGE, "")

    # If requested, stop here and let the user sign the CSR
    if stop_at_csr:
      print("Stopping after CSR generation. CSR is located at: %s" % csr_file)
      print("After signing the CSR, continue Auto-TLS setup by rerunning " +
               "certmanager setup and passing in --signed-ca-cert " +
               "<signed_ca_chain.pem>")
      return

    sign_cert(csr_file, ca_cert_file, ca_dir, password, sig_algo,
              expiration, self.trust_files, True)
    os.unlink(csr_file)

  def init_truststores(self, signed_ca_cert=None):
    cfg = self.cfg
    keytool = cfg.keytool
    keystore_type = cfg.keystore_type
    ca_cert_file = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]

    if signed_ca_cert:
      LOG.info("Copying override CA cert from: %s" % signed_ca_cert)
      shutil.copy(signed_ca_cert, ca_cert_file)
      self.os_ops.set_path_metadata(ca_cert_file, self.cfg.cm_user,
                                    self.cfg.cm_group, mode=0o644)

    # Create the in-cluster truststore containing the ca cert
    truststore_file = self.trust_files[IN_CLUSTER_TLS_SET][JKS_TLS_TYPE]
    truststore_password = read_obfuscated_password(
                  self.password_files[IN_CLUSTER_TLS_SET][TRUST_ENTITY])
    generate_truststore(keytool, truststore_file, truststore_password,
                        ca_cert_file, keystore_type)

    # Create the global truststore, also containing the ca cert
    truststore_file = self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE]
    truststore_password = read_obfuscated_password(
                  self.password_files[GLOBAL_TLS_SET][TRUST_ENTITY])
    generate_truststore(keytool, truststore_file, truststore_password,
                        ca_cert_file, keystore_type)

    # Add the ca cert to the global ca-certs
    with open(ca_cert_file, 'r') as r:
      with open(self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE], 'w') as w:
        w.write(r.read())

    # Truststore doesn't contain sensitive secrets. In particular, YARN jobs need
    # to be able to read it, so make it world-readable.
    os.chmod(ca_cert_file, 0o644)
    os.chmod(self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE], 0o644)

    # Create the lock file
    open(os.path.join(self.cmca_dir, CMCA_SIGNING_LOCK_FILE), "w").close()

    self.chown_tree(self.certmanager_dir)

  def export_ca_cert(self):
    """
    When the CA is of type "internal", this command dumps
    out the root CA certificate in PEM format to stdout.
    It is an error to use this command when the CA type is
    other than "internal"
    """
    assert self.is_internal_ca
    ca_cert_file = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
    if not os.path.exists(ca_cert_file):
      raise RuntimeError("File %s does not exist. This command can only be"
                         " run after certificates have been generated."
                         " It must be run on the CM host." % ca_cert_file)
    with open(ca_cert_file, 'r') as f:
      sys.stdout.write(f.read())

  def _import_root_cert(self, cert_file, cert_index):
    # First, verify that the cert_file is a valid self-signed cert file
    # in PEM format by running:
    # openssl verify -CAfile $cert_file $cert_file
    p2 = Popen(["openssl", "verify",
               "-CAfile", cert_file,
               cert_file],
              stdin=None, stdout=PIPE, stderr=STDOUT)
    p2.wait()
    if 0!=p2.returncode:
      LOG.error("Importing %s failed. Exit code: %d. Output:\n%s" %
                (cert_file, p2.returncode, "".join(p2.stdout.readlines())))
      raise Exception("%s not a valid self-signed cert in PEM format"
                      % cert_file)

    # Add cert file to global ca-certs file
    with open(cert_file, 'r') as r:
      with open(self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE], 'a') as w:
        w.write(r.read())

    # Add cert to java truststore
    # Get an alias for the cert, using md5 of the file
    md5=hashlib.md5()
    with open(cert_file, "rb") as f:
      md5.update(f.read())
    alias="imported-ca-%s" % md5.hexdigest()

    #
    read_fd, write_fd = os.pipe()
    p1 = Popen(["openssl", "x509",
                "-inform", "PEM",
                "-outform", "PEM",
                "-in", cert_file,
                "-out", "/dev/fd/%d"% write_fd],
               stdout=PIPE, stderr=STDOUT)
    os.close(write_fd)
    p2 = Popen( [ self.cfg.keytool, "-importcert",
                "-noprompt",
                "-keystore", self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE],
                "-storetype", self.cfg.keystore_type,
                "-alias", alias,
                "-file", "/dev/fd/%d" % read_fd,
                "-storepass:file", "/dev/fd/0"],
              stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    os.close(read_fd)
    p2.stdin.write(read_obfuscated_password(
                   self.password_files[GLOBAL_TLS_SET][TRUST_ENTITY]))
    p2.stdin.close()
    p1.wait()
    p2.wait()
    if p1.returncode!=0 or p2.returncode!=0:
      LOG.error("keytool -importcert %s failed. Exit codes: (%d|%d)."
                " Output from openssl:\n%sOutput from keytool:\n%s"
                % (cert_file, p1.returncode, p2.returncode,
                   "".join(p1.stdout.readlines()),
                   "".join(p2.stdout.readlines())))
      raise Exception("Could not add cert to truststore")

  def import_trusted_ca_certs(self, trusted_ca_certs, skip_invalid_ca_certs):
    if self.cfg.trusted_ca_certs and trusted_ca_certs:
      raise Exception("Cannot specify trusted CA certs in both configuration "
                      "and command line. Config: %s, command line: %s" %
                      (self.cfg.trusted_ca_certs, trusted_ca_certs))
    elif not trusted_ca_certs:
      trusted_ca_certs = self.cfg.trusted_ca_certs

    if not trusted_ca_certs:
      return

    if not os.path.isfile(trusted_ca_certs):
      raise Exception("trusted_ca_certs needs to be a file. Got %s"
                      % trusted_ca_certs)
    LOG.info("Importing trusted CA certs from: %s" % trusted_ca_certs)
    iterate_pem_certs(trusted_ca_certs, skip_invalid_ca_certs,
                      self._import_root_cert)

  def _write_key_chain_file(self,
                            client_key_file,
                            client_cert_file,
                            key_chain_file):
    """
    Copy key file and add chain to make a file for the host containing
    everything
    """
    shutil.copy(client_key_file, key_chain_file)
    with open(key_chain_file, 'a') as key:
      with open(client_cert_file, 'r') as chain:
        key.write(chain.read())

    self.os_ops.set_path_metadata(key_chain_file, self.cfg.cm_user,
                                  self.cfg.cm_group, mode=0o600)

  def _gen_host_cert_files(self,
                          hostname,
                          subject,
                          subjectAltNames,
                          host_dir,
                          password):
    """
    Create certifictes/keys for a host.
    :param cfg The configuration
    :param hostname The name of the host. Ideally the FQDN, but can be
           anything CM uses to identify the host by.
    :param subject The subject DN to use in the host's certificate
    :param subjectAltNames The subject alternate names to add to the
           certificate
    :param host_dir Where to store all the generate files for this host
    :param password The password to use for the host's private key and
           JKS keystore
    """

    client_key_file = os.path.join(host_dir, HOST_KEY_FILE_NAME)
    csr_file = os.path.join(host_dir, HOST_CSR_FILE_NAME)
    client_cert_file = os.path.join(host_dir, HOST_CERT_CHAIN_FILE_NAME)
    client_pw_file = os.path.join(host_dir, HOST_KEY_PW_FILE_NAME)
    keystore_file = os.path.join(host_dir, HOST_KEYSTORE_FILE_NAME)
    key_chain_file=os.path.join(host_dir, HOST_KEY_CERT_CHAIN_FILE_NAME)
    pkcs12_file = os.path.join(host_dir, HOST_PKCS12_FILE_NAME)

    # Validations
    host_expiration=self.cfg.host_expiration
    try:
      datetime.strptime(host_expiration,'%y%m%d')
    except ValueError:
      raise ValueError("Expected a valid date for host_expiration in YYMMDD"
                       " format. Got: %s" % host_expiration)

    # Generate a csr (which also generates the password-protected private key)
    generate_host_csr(csr_file, client_key_file,
                      self.cfg.host_key_algo, self.cfg.host_key_args,
                      self.cfg.key_encryption_algo, password,
                      subject, subjectAltNames)
    # Sign CSR, while protecting us from other folks who might be
    # also trying the same thing
    with open(os.path.join(self.cmca_dir, CMCA_SIGNING_LOCK_FILE), "w") \
        as lockfile:
      fcntl.lockf(lockfile, fcntl.LOCK_EX, 0, 0, os.SEEK_SET)
      try:
        sign_host_csr_with_internal_ca(client_cert_file, csr_file,
                                       self.cmca_dir,
                                       self.cfg.host_sig_hash_algo,
                                       self.cfg.host_expiration,
                                       self.trust_files)
      finally:
        fcntl.lockf(lockfile, fcntl.LOCK_UN, 0, 0, os.SEEK_SET)

    # Add CA cert to bottom of client file, making it a chain
    with open(self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE], 'r') as ca:
      with open(client_cert_file, 'a') as chain:
        chain.write(ca.read())

    self._write_key_chain_file(client_key_file, client_cert_file,
                               key_chain_file)

    # TODO avoid writing out clear text password if possible.
    # For now, we save the cleartext password in a password file
    with os.fdopen(os.open(client_pw_file, os.O_CREAT|os.O_WRONLY, 0o600),
                   "w") as f:
      f.write(password)

    os.unlink(csr_file)

    self._write_keystore_file(client_cert_file, client_key_file, pkcs12_file,
                              keystore_file, hostname, password)

  def _write_keystore_file(self,
                           client_cert_file,
                           client_key_file,
                           pkcs12_file,
                           keystore_file,
                           hostname,
                           password):
    """
    Put the cert chain and private key in a keystore for the host.
    """
    # Step 1: Generate a PKCS12 keystore
    ca_file = os.path.join(self.truststore_dir, IN_CLUSTER_CA_CERT_FILE_NAME)
    p1_read_fd, p1_write_fd = os.pipe()
    os.write(p1_write_fd, password)
    os.close(p1_write_fd)
    p2_read_fd, p2_write_fd = os.pipe()
    os.write(p2_write_fd, password)
    os.close(p2_write_fd)
    cmd = Popen(["openssl", "pkcs12",
           "-export",
           "-chain",
           "-CAfile", ca_file,
           "-in", client_cert_file,
           "-inkey", client_key_file,
           "-passin", "fd:%d" % p1_read_fd,
           "-passout", "fd:%d" % p2_read_fd,
           "-out", pkcs12_file,
           "-name", hostname ],
          stdout=PIPE, stderr=STDOUT)
    os.close(p1_read_fd)
    os.close(p2_read_fd)
    cmd.wait()
    if cmd.returncode!=0:
      LOG.error("openssl pkcs12 failed for %s. Exit code: %d. Output:\n%s" %
                (hostname, cmd.returncode, "".join(cmd.stdout.readlines())))
      raise Exception("Failed to generate host pkcs12 file.")

    # Step 2: Convert PKCS12 keystore to Java default keystore
    # We will need to pass 3 passwords to keytool, which we do via pipes
    # 1) Password for the PKCS12 store created above
    # 2) Password for the java keystore being created
    # 3) Password for the key being stored in the java keystore
    # We use the same password for all 3 things, but we didn't have to.
    # Regardless, we must specify each password individually
    read1_fd, write1_fd = os.pipe()
    os.write(write1_fd, password)
    os.close(write1_fd)
    read2_fd, write2_fd = os.pipe()
    os.write(write2_fd, password)
    os.close(write2_fd)
    read3_fd, write3_fd = os.pipe()
    os.write(write3_fd, password)
    os.close(write3_fd)
    cmd = Popen([self.cfg.keytool, "-importkeystore",
                 "-srckeystore", pkcs12_file,
                 "-srcstoretype", "PKCS12",
                 "-srcalias", hostname,
                 "-destkeystore", keystore_file,
                 "-deststoretype", self.cfg.keystore_type,
                 "-destalias", hostname,
                 "-srcstorepass:file",  "/dev/fd/%d" % read1_fd,
                 "-deststorepass:file", "/dev/fd/%d" % read2_fd,
                 "-destkeypass:file",  "/dev/fd/%d" % read3_fd],
                stdout=PIPE, stderr=STDOUT)
    os.close(read1_fd)
    os.close(read2_fd)
    os.close(read3_fd)
    cmd.wait()
    if cmd.returncode!=0:
      LOG.error("keytool -importkeystore failed for %s. Exit code: %d."
                " Output:\n%s" %
                (hostname, cmd.returncode, "".join(cmd.stdout.readlines())))
      raise Exception("Failed to generate host keystore file.")
    os.unlink(pkcs12_file)

    self.os_ops.set_path_metadata(keystore_file, self.cfg.cm_user,
                                  self.cfg.cm_group, mode=0o600)

  def _write_output(self, output, host_dir):
    """
    Tars host_dir and either writes to a file or outputs to stdout
    """
    if output=="-":
      filename=None
      bufer=StringIO.StringIO() # buffer is python reserved
      is_stdout_write=True
    else:
      filename=output
      bufer=None
      is_stdout_write=False
    with contextlib.closing(tarfile.TarFile(filename, 'w', bufer)) as tar:
      # Add all the trust related files
      tar.add(self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE],
              GLOBAL_CA_CERT_FILE_NAME)
      tar.add(self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE],
              GLOBAL_TRUSTSTORE_FILE_NAME)
      tar.add(self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE],
              IN_CLUSTER_CA_CERT_FILE_NAME)
      tar.add(self.trust_files[IN_CLUSTER_TLS_SET][JKS_TLS_TYPE],
              IN_CLUSTER_TRUSTSTORE_FILE_NAME)
      # Add all of this host's own key / cert related files
      for host_file in os.listdir(host_dir):
        tar.add(os.path.join(host_dir, host_file), host_file)

      for item in tar.getmembers():
        if item.isdir():
          item.mode |= 0o755

    if is_stdout_write:
      sys.stdout.write(bufer.getvalue())
      bufer.close()

  def gen_node_cert(self, output, hostname, altnames, rotate, do_chown):
    """
    Given a hostname, and optional alternate names, creates a certificate
    chain, valid for this host (and alternate names)
    to use as a TLS server and client. The chain is rooted at the CA that is
    configured to sign certicates for this cluster.

    This command creates a chain as described above and maintains it in the
      certificate repository.

    If "output" is specified, then a .tar file containing the host-specific
      keys, certificate and CA certificate will be generated.
    If the "output" set to "-" will result in the output being directed
      to stdout.
    If output is not specified, this script generates the certificates but
      does not output anything

    The hostname (or IP) we are generating the cert for must be a valid DNS
    name or IPv4 address. This must be the FQDN that is used by CM to identify
    this host.

    \b
    If altnames are specified, they indicate the additional subject alt names
    to add to the certificate. The hostname is added automatically. Multiple
    alternate names may be specified. Each must be in one of the following
    formats:
    1) DNS:<valid-dns-name>
    2) IP:<valid-IPv4-address>
    3) email:<valid-email-address>

    If rotate is true, then new keys/certificates will be generated even if
    existing ones are present. Otherwise, the current keys/certificates will be
    returned.

    If do_chown is true, then the host_dir directory will be set to be
    owned by the cloudera-scm user.
    """

    altNames = gen_altNames(hostname, self.cfg.email_address, altnames)

    password = read_obfuscated_password(
                  self.password_files[GLOBAL_TLS_SET][PROOF_ENTITY])

    host_dir = self._host_dir(hostname)
    if not os.path.isdir(host_dir):
      # In case the FQDN is too long, try removing the domain
      shortName = hostname
      delimiter = hostname.find(".")
      if delimiter > -1:
        shortName = hostname[:delimiter]

      subject = gen_subject(self.cfg.subject_suffix, hostname, shortName)
      self.makedirs(host_dir, mode=0o755)
      self._gen_host_cert_files(hostname, subject, altNames,
                                host_dir, password)
      if do_chown:
        self.chown_tree(host_dir)
    else:
      if rotate:
        backup_dir = _make_backup_dir(host_dir)
        LOG.info("Directory %s already exists. Rotating and generating new"
                 " keys and certificates. The old certificates will be backed"
                 " up to %s." % (host_dir, backup_dir))
        os.rename(host_dir, backup_dir)
        return self.gen_node_cert(output, hostname, altnames, False, do_chown)
      else:
        LOG.info("Directory %s already exists. Reusing existing certificates."
                 " Alt-names / Attributes / Validity of old certificates will"
                 " remain in effect, overriding current specs if different."
                 % host_dir)

    if output:
      self._write_output(output, host_dir)

  def copy_node_cert(self, output, hostname):
    """
    Retrieves the key/cert corresponding to a host and tars them
    """
    host_dir = self._host_dir(hostname)
    if not os.path.isdir(host_dir):
      raise Exception("No directory found for host '%s' at location: %s" %
                      (hostname, host_dir))

    client_key_file = os.path.join(host_dir, HOST_KEY_FILE_NAME)
    if not os.path.isfile(client_key_file):
      raise Exception("No key found for host '%s' at location: %s" %
                      (hostname, client_key_file))

    client_cert_file = os.path.join(host_dir, HOST_CERT_CHAIN_FILE_NAME)
    if not os.path.isfile(client_cert_file):
      raise Exception("No certificate found for host '%s' at location: %s" %
                      (hostname, client_cert_file))

    client_pw_file = os.path.join(host_dir, HOST_KEY_PW_FILE_NAME)
    password = ""
    if not os.path.isfile(client_pw_file):
      # Assume this uses the in-cluster password file and write it out
      LOG.info("No password file found for host '%s' at location: %s. Assuming "
               "default in-cluster password." % (hostname, client_pw_file))
      password = read_obfuscated_password(
        self.password_files[GLOBAL_TLS_SET][PROOF_ENTITY])
      with self.os_ops.open_write_file(client_pw_file, self.cfg.cm_user,
                                       self.cfg.cm_group) as pw_file:
        pw_file.write(password)
    else:
      with open(client_pw_file) as pw_file:
        password = pw_file.read().strip()

    keystore_file = os.path.join(host_dir, HOST_KEYSTORE_FILE_NAME)
    if not os.path.isfile(keystore_file):
      LOG.info("No keystore file found for host '%s' at location: %s. "
               "Converting PEM key to JKS." % (hostname, keystore_file))
      pkcs12_file = os.path.join(host_dir, HOST_PKCS12_FILE_NAME)
      self._write_keystore_file(client_cert_file, client_key_file, pkcs12_file,
                                keystore_file, hostname, password)

    key_chain_file = os.path.join(host_dir, HOST_KEY_CERT_CHAIN_FILE_NAME)
    if not os.path.isfile(key_chain_file):
      LOG.info("No keychain file found for host '%s' at location: %s. "
               "Appending PEM key and PEM cert files."
               % (hostname, key_chain_file))
      self._write_key_chain_file(client_key_file, client_cert_file,
                                 key_chain_file)

    if output:
      self._write_output(output, host_dir)

  def setup_server_certs(self, hostname, altname):
    """
    This command configures the SCM server on this host for TLS. When using
    an internal CA, it generates certificates using the given hostname
    (if any) and alternate names.

    In addition, this command:

    1) Creates a configuration wrapper for CM server, which injects a set
      of configurations into CM server (at start time).  This will configure
      CM server to use the keys and certificates in the repository for
      communications with agents.

    2) CM will be configured to refer to this certificate repository to
      generate certificates and keys for all new hosts that it adds.

    3) After execution a CM server restart is required.

    \b
    If alternate names are provided, they must be of one of the following forms:
    1) DNS:<dns-name>
    2) IP:<ipv4-address>
    3) email:<email-address>
    """
    cfg = self.cfg

    cm_certs_dir = self.certmanager_dir
    if not cm_certs_dir:
      raise ValueError("cm_certs_dir must be provided in config file")
    if not os.path.isabs(cm_certs_dir):
      raise ValueError("cm_certs_dir should be an absolute path. Got: %s"
                       % cm_certs_dir)

    # Create the cm_certs_dir, with mode 0700 with all ancestors created, if
    # necessary, with mode 0755. This will eventually be chowned to the SCM
    # user
    if not os.path.isdir(cm_certs_dir):
      self.makedirs(cm_certs_dir, mode=0o755)
    # Check that this path will be accessbile by the SCM server
    try:
      self.check_user_access(cm_certs_dir)
    except:
      # Cleanup, as much as we can
      os.rmdir(cm_certs_dir)
      raise

    os.chmod(cm_certs_dir, 0o755)


    cm_defaults = cfg.cm_defaults

    keystore_password = read_obfuscated_password(
      self.password_files[GLOBAL_TLS_SET][PROOF_ENTITY])
    truststore_password = read_obfuscated_password(
      self.password_files[GLOBAL_TLS_SET][TRUST_ENTITY])

    if altname is None:
      altname = []

    if not os.path.exists(cm_certs_dir):
      self.makedirs(cm_certs_dir, mode=0o755)

    altNames = gen_altNames(hostname, cfg.email_address, altname)

    # In case the FQDN is too long, try removing the domain
    shortName = hostname
    delimiter = hostname.find(".")
    if delimiter > -1:
        shortName = hostname[:delimiter]

    subject = gen_subject(cfg.subject_suffix, hostname, shortName)
    host_dir = os.path.join(
                os.path.join(self.certmanager_dir, HOST_KEYSTORE_DIR_NAME),
                hostname)
    if not os.path.isdir(host_dir):
      self.makedirs(host_dir, mode=0o755)

    self._gen_host_cert_files(hostname, subject, altNames, host_dir, keystore_password)

    # Generate the wrapper script that CM server will invoke.
    generator = os.path.join(cm_certs_dir, "generate_host_cert")
    with open(generator, "w") as f:
      wrapper = """#!/bin/bash
      exec {exec_name} --location {location} gen_node_cert --output=- "$@"
      """.format(exec_name=sys.argv[0], location=self.certmanager_dir)
      f.write(textwrap.dedent(wrapper))
    os.chmod(generator, 0o755)

    self.chown_tree(cm_certs_dir)

  def init_custom_certdir(self, hostname, host_cert, host_key, ca_cert):
    """
    Creates a custom certdir with a CA cert, host cert, and host key
    """
    cm_certs_dir = self.certmanager_dir
    if not cm_certs_dir:
      raise ValueError("cm_certs_dir must be provided in config file")
    if not os.path.isabs(cm_certs_dir):
      raise ValueError("cm_certs_dir should be an absolute path. Got: %s"
                       % cm_certs_dir)

    if not host_cert and not host_key and not ca_cert:
      return

    if host_cert or host_key:
      self.add_custom_cert(hostname, host_cert, host_key)

    if not os.path.isdir(self.truststore_dir):
      self.makedirs(self.truststore_dir, mode=0o755)

    if ca_cert:
      ca_cert_file = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
      shutil.copy(ca_cert, ca_cert_file)
      self.os_ops.set_path_metadata(ca_cert_file, self.cfg.cm_user,
                                    self.cfg.cm_group, mode=0o644)
      os.chmod(ca_cert_file, 0o644)

  def add_custom_cert(self, hostname, host_cert, host_key):
    """
    Copies a key/cert for a host to the custom certdir
    """
    if not os.path.isdir(self.hosts_keystores_dir):
      self.makedirs(self.hosts_keystores_dir)

    host_dir = self._host_dir(hostname)
    if os.path.isdir(host_dir):
      backup_dir = _make_backup_dir(host_dir)
      LOG.info("Directory %s already exists. The old certificates will be "
               "backed up to %s." % (host_dir, backup_dir))
      os.rename(host_dir, backup_dir)

    self.makedirs(host_dir)

    if host_cert:
      cert_file = os.path.join(host_dir, HOST_CERT_CHAIN_FILE_NAME)
      shutil.copy(host_cert, cert_file)
      self.os_ops.set_path_metadata(cert_file, self.cfg.cm_user,
                                    self.cfg.cm_group, mode=0o644)

    if host_key:
      key_file = os.path.join(host_dir, HOST_KEY_FILE_NAME)
      shutil.copy(host_key, key_file)
      self.os_ops.set_path_metadata(key_file, self.cfg.cm_user,
                                    self.cfg.cm_group, mode=0o600)

  def setup_server_with_custom_certs(self, hostname, keystore_password,
                                     truststore_password):
    """
    Configures CM server to use a custom certificate directory
    """
    cm_certs_dir = self.certmanager_dir

    if not os.path.isdir(cm_certs_dir):
      raise ValueError("cm_certs_dir does not exist")
    # Check that this path will be accessbile by the SCM server
    else:
      os.chmod(cm_certs_dir, 0o755)

    if hostname is None:
      hostname = socket.gethostname()

    if not os.path.isdir(self.certmanager_passwords_dir):
      self.makedirs(self.certmanager_passwords_dir)

    # Generate all the password files
    for _,tls_set in self.password_files.items():
      write_obfuscated_password(tls_set[PROOF_ENTITY], keystore_password)
      write_obfuscated_password(tls_set[TRUST_ENTITY], truststore_password)

    cluster_ca_pem = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
    if not os.path.isfile(cluster_ca_pem):
      raise Exception("No in-cluster truststore found at location: %s"
                      % cluster_ca_pem)

    cluster_ca_jks = self.trust_files[IN_CLUSTER_TLS_SET][JKS_TLS_TYPE]
    if not os.path.isfile(cluster_ca_jks):
      LOG.info("Could not find JKS truststore at location: %s. Converting "
               "PEM truststore to JKS." % cluster_ca_jks)
      generate_truststore(self.cfg.keytool, cluster_ca_jks, truststore_password,
                          cluster_ca_pem, self.cfg.keystore_type)

    global_ca_pem = self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE]
    copied_cluster_to_global = False
    if not os.path.isfile(global_ca_pem):
      LOG.info("No global PEM truststore found at location: %s. Copying "
               "in-cluster truststore to use as global truststore." %
               global_ca_pem)
      shutil.copy(cluster_ca_pem, global_ca_pem)
      copied_cluster_to_global = True

    global_ca_jks = self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE]
    if not os.path.isfile(global_ca_jks):
      if copied_cluster_to_global:
        LOG.info("No global JKS truststore found at location: %s. Copying "
                 "in-cluster truststore to use as global truststore." %
                 global_ca_jks)
        shutil.copy(cluster_ca_jks, global_ca_jks)
      else:
        raise Exception("Global PEM truststore found, but JKS truststore is "
                        "missing. Please convert PEM truststore to JKS at: %s" %
                        global_ca_jks)

    # Ensure there are certificates for the CM host and generate missing files
    self.copy_node_cert(None, hostname)

    # Generate the wrapper script that CM server will invoke.
    generator = os.path.join(cm_certs_dir, "generate_host_cert")
    with open(generator, "w") as f:
      wrapper = """#!/bin/bash
      exec {exec_name} --location {location} copy_node_cert --output=- "$@"
      """.format(exec_name=sys.argv[0], location=self.certmanager_dir)
      f.write(textwrap.dedent(wrapper))
    os.chmod(generator, 0o755)

    self.chown_tree(cm_certs_dir)

  def _host_dir(self, hostname):
    return os.path.join(self.hosts_keystores_dir, hostname)

  def host_files(self, hostname):
    """
    Identify all files for a host.
    """
    host_dir = self._host_dir(hostname)
    out = {}
    for x in ['HOST_KEY_FILE_NAME', "HOST_CSR_FILE_NAME",
              'HOST_CERT_CHAIN_FILE_NAME',
              "HOST_KEY_PW_FILE_NAME",
              "HOST_KEYSTORE_FILE_NAME",
              "HOST_KEY_CERT_CHAIN_FILE_NAME",
              "HOST_PKCS12_FILE_NAME"]:
      out[x] = os.path.join(host_dir, globals()[x])

    out['GLOBAL_CA_CERT_FILE_NAME'] = self.trust_files[GLOBAL_TLS_SET][PEM_TLS_TYPE]
    out['GLOBAL_TRUSTSTORE_FILE_NAME'] = self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE]
    out['IN_CLUSTER_CA_CERT_FILE_NAME'] = self.trust_files[IN_CLUSTER_TLS_SET][PEM_TLS_TYPE]
    out['IN_CLUSTER_TRUSTSTORE_FILE_NAME'] = self.trust_files[IN_CLUSTER_TLS_SET][JKS_TLS_TYPE]
    return out

  def bootstrap_cm_keystores(self, hostname):
    # Copies keystore and truststore to /var/lib/cloudera-scm-agent/agent-cert
    # This is normally done during host install or GenerateHostCerts, but CM
    # needs these files to come up with TLS before then.
    LOG.info("Bootstrapping keystore and truststore to: %s" % DEFAULT_AGENT_CERTS_DIR)

    src_keystore = os.path.join(self._host_dir(hostname), HOST_KEYSTORE_FILE_NAME)
    src_truststore = self.trust_files[GLOBAL_TLS_SET][JKS_TLS_TYPE]

    dst_keystore = os.path.join(DEFAULT_AGENT_CERTS_DIR, HOST_KEYSTORE_FILE_NAME)
    dst_truststore = os.path.join(DEFAULT_AGENT_CERTS_DIR, GLOBAL_TRUSTSTORE_FILE_NAME)

    self.makedirs(DEFAULT_AGENT_CERTS_DIR, mode=0o755)
    shutil.copy(src_keystore, dst_keystore)
    shutil.copy(src_truststore, dst_truststore)
    self.chown_tree(DEFAULT_AGENT_CERTS_DIR)

  def setup_cm_server(self, hostname, write_file, configure_services):
    # Generate the initialization commands for CM server to force the TLS
    # configuration.
    cm_script = """
    setsettings AGENT_TLS true
    setsettings WEB_TLS true
    setsettings NEED_AGENT_VALIDATION true
    setsettings KEYSTORE_PATH {keystore}
    setsettings KEYSTORE_PASSWORD {keystore_password}
    setsettings TRUSTSTORE_PATH {truststore}
    setsettings TRUSTSTORE_PASSWORD {truststore_password}
    setsettings HOST_CERT_GENERATOR {generator}
    setsettings SSL_CERTIFICATE_HOSTNAME {hostname}
    setsettings AUTO_TLS_KEYSTORE_PASSWORD {auto_tls_keystore_password}
    setsettings AUTO_TLS_TRUSTSTORE_PASSWORD {auto_tls_truststore_password}
    """

    cm_certs_dir = self.certmanager_dir
    host_dir = self._host_dir(hostname)
    if not cm_certs_dir:
      raise ValueError("cm_certs_dir must be provided in config file")
    if not os.path.isabs(cm_certs_dir):
      raise ValueError("cm_certs_dir should be an absolute path. Got: %s"
                       % cm_certs_dir)
    keystore_password = read_obfuscated_password(
      self.password_files[GLOBAL_TLS_SET][PROOF_ENTITY])
    truststore_password = read_obfuscated_password(
      self.password_files[GLOBAL_TLS_SET][TRUST_ENTITY])

    if configure_services:
      cm_script += "setsettings AUTO_TLS_TYPE ALL\n"

    generator = os.path.join(cm_certs_dir, "generate_host_cert")
    cm_script = cm_script.format(
      keystore=os.path.join(DEFAULT_AGENT_CERTS_DIR, HOST_KEYSTORE_FILE_NAME),
      keystore_password=keystore_password,
      truststore=os.path.join(DEFAULT_AGENT_CERTS_DIR, GLOBAL_TRUSTSTORE_FILE_NAME),
      truststore_password=truststore_password,
      auto_tls_keystore_password=keystore_password,
      auto_tls_truststore_password=truststore_password,
      generator=generator,
      hostname=hostname)

    if not write_file:
      # Don't change CM server config, just print the settings and return. This
      # is used when certmanager is invoked as a CM command, and CM can set the
      # configs itself.
      print(textwrap.dedent(cm_script))
      return

    cm_init_file = os.path.join(cm_certs_dir, "cm_init.txt")
    with os.fdopen(os.open(cm_init_file, os.O_CREAT|os.O_WRONLY, 0o600),
                   "w") as f:
      f.write(textwrap.dedent(cm_script))
    self.chown_tree(cm_init_file)

    # We add a high-entropy (meaning I generated it randomly and will not
    # use it anywhere else) marker to mark the begin and end of the block
    # we are creating so we can automatically remove it if the need so
    # arises.
    block_marker_id="FGJqR8zvlo9SZ2rlDDp7"
    # Update the defaults file
    cfg_line = '''
    # Automatically added block below. Do Not edit. AUTOGEN-BLOCK-BEGIN-{block_marker_id}
    export CMF_SERVER_ARGS="$CMF_SERVER_ARGS -i {cm_init_file}"
    export CMF_FF_AUTO_TLS=true
    # Automatically added block above. Do Not edit. AUTOGEN-BLOCK-END-{block_marker_id}
    '''
    cfg_line = cfg_line.format(block_marker_id=block_marker_id,
                               cm_init_file=cm_init_file)
    cm_defaults = self.cfg.cm_defaults
    with open(cm_defaults, "a") as f:
      f.write(textwrap.dedent(cfg_line))

    self.chown_tree(cm_defaults)
    self.check_user_access(cm_defaults)

    self.chown_tree(self.certmanager_dir)

  def setup_agent_certs(self, tarFile,
                        agent_cert_dir,
                        agent_conf_file):
    tar = tarfile.TarFile(tarFile)
    tar.extractall(agent_cert_dir)

    cfg_frag = """
    [Security]
    use_tls = 1
    verify_cert_file = {ca_cert}
    client_key_file = {host_key}
    client_keypw_file = {host_key_pw}
    client_cert_file = {host_cert}
    """
    cfg_frag = cfg_frag.format(
      ca_cert=os.path.join(agent_cert_dir, IN_CLUSTER_CA_CERT_FILE_NAME),
      host_key=os.path.join(agent_cert_dir, HOST_KEY_FILE_NAME),
      host_cert=os.path.join(agent_cert_dir, HOST_CERT_CHAIN_FILE_NAME),
      host_key_pw=os.path.join(agent_cert_dir, HOST_KEY_PW_FILE_NAME))
    # Append the configuration fragment.  This will override any
    # previous settings of these items.
    with open(agent_conf_file, "a") as f:
      f.write(textwrap.dedent(cfg_frag))

  def gen_token_signing_key(self):
    LOG.info("Generating key used to sign certificate request tokens")
    password = generate_random_password()
    write_obfuscated_password(self.token_password_file, password)
    self.os_ops.set_path_metadata(self.token_password_file, self.cfg.cm_user,
                                  self.cfg.cm_group, mode=0o600)

  def gen_cert_request_token(self, output, hostname, hostname_pattern, lifetime):
    """
    Generates a certificate request token. A token is a JSON structure appended
    with its HMAC digest. The digest allows tampering to be detected. The JSON
    contains the following fields:
    * One of hostname or hostname_pattern: Determines what hostnames this token
    can generate certificates for. hostname refers to a specific hostname, while
    hostname_pattern is a regex that allowed hostnames must match.
    * expiration: When the token expires, or 0 for no expiration.

    Hex-encoded HMAC-SHA256 is used as the HMAC digest.
    """
    if not os.path.exists(self.token_password_file):
      self.gen_token_signing_key()
    password = read_obfuscated_password(self.token_password_file)

    if lifetime == 0:
      expiration = 0
    else:
      expiration = time.time() + lifetime

    LOG.info("Generating certificate request token for hostname pattern '%s' "
             "and expiration '%s'" % (hostname, expiration))

    if hostname:
      token = json.dumps({"hostname": hostname, "expiration": expiration})
    elif hostname_pattern:
      token = json.dumps({"hostname_pattern": hostname_pattern,
                          "expiration": expiration})
    token_sig = hmac.new(password, token, hashlib.sha256).hexdigest()

    with open(output, 'w') as f:
      f.write("%s\n%s\n" % (token, token_sig))

    # A token has privileges to generate a valid cert, making it sensitive
    os.chmod(output, 0o600)

  def verify_cert_request_token(self, token, token_sig, hostname):
    """
    Verifies a certificate request token. The following checks are done:
    * Hex-encoded HMAC-SHA256 digest matches the one in the signature
    * One of hostname or hostname_pattern is present in the JSON
    * Expiration field is present in the JSON
    * Either expiration is 0 or the current time is less than the expiration
    * If hostname is present, then the hostname being generated matches the
    token hostname exactly
    * If hostname_pattern is present, then the hostname being generated matches
    the regex in the hostname_pattern as a whole-string match
    """
    LOG.info("Checking certificate request token: '%s', signature: '%s', for "
             "hostname: '%s'" % (token, token_sig, hostname))

    if not os.path.exists(self.token_password_file):
      raise Exception("Token signing key is not present")
    password = read_obfuscated_password(self.token_password_file)

    new_token_sig = hmac.new(password, token, hashlib.sha256).hexdigest()
    if not compare_digest(token_sig, new_token_sig):
      LOG.error("Signature verification failed")
      raise Exception("Invalid token")

    token_obj = json.loads(token)

    if "hostname" in token_obj and "hostname_pattern" in token_obj:
      LOG.error("Both hostname and hostname_pattern present in token")
      raise Exception("Invalid token")

    if "hostname" not in token_obj and "hostname_pattern" not in token_obj:
      LOG.error("Missing hostname/hostname_pattern in token")
      raise Exception("Invalid token")

    if "expiration" not in token_obj:
      LOG.error("Missing expiration in token")
      raise Exception("Invalid token")

    expiration = token_obj["expiration"]
    if expiration > 0 and time.time() > token_obj["expiration"]:
      LOG.error("Token is expired")
      raise Exception("Invalid token")

    if "hostname" in token_obj:
      expected_hostname = token_obj["hostname"]
      if hostname != expected_hostname:
        LOG.error("Hostname '%s' does not match token's hostname '%s'" %
                  (hostname, expected_hostname))
        raise Exception("Invalid token")
    elif "hostname_pattern" in token_obj:
      pattern = "^%s$" % token_obj["hostname_pattern"]
      if not re.match(pattern, hostname):
        LOG.error("Hostname '%s' does not match token's hostname pattern '%s'" %
                  (hostname, pattern))
        raise Exception("Invalid token")

# Click wrappers

@click.group()
@click.pass_context
@click.option("--location", metavar="<certmanager-dir-root>",
              default=DEFAULT_CERTMANAGER_ROOT_DIR, required=False,
              help="The directory where the certmanager will store all"
                   " its files.",
              type=click.Path(file_okay=False, dir_okay=True,
                              allow_dash=False, resolve_path=True,
                              readable=True))
def certmanager(ctx, location):
  """
  Cloudera Certificate Manager

  Manages certificates for the cluster.

  Run this as root.
  """
  logging.basicConfig(
    level=logging.DEBUG if 'VERBOSE' in os.environ else logging.INFO,
    datefmt=DATE_FORMAT)

  ctx.obj.certmanager = CertManager(location)

  # Initialize log file
  setup_rolling_logging(DEFAULT_LOG_FILE)
  LOG.info("SCM Certificate Manager")

@click.group()
@click.pass_context
@click.option("--location", metavar="<certmanager-dir-root>",
              default=DEFAULT_CERTMANAGER_ROOT_DIR, required=False,
              help="The directory where the certmanager will store all"
                   " its files.",
              type=click.Path(file_okay=False, dir_okay=True,
                              allow_dash=False, resolve_path=True,
                              readable=True))
def dev_tools(ctx, location):
  """
  This is the dev tooling for the certmanager which only shows up if you
  pass "--dev" as the first argument to the certmanager.

  This provided all the regular functionality of the certmanager, plus a
  few additional commands that are only meant for dev / test use.
  """
  logging.basicConfig(
    level=logging.DEBUG if 'VERBOSE' in os.environ else logging.INFO,
    datefmt=DATE_FORMAT)
  ctx.obj.certmanager = CertManager(location)



@certmanager.command(short_help="INTERNAL: Generate the certificates and"
                     " truststore for a new node to be added to the cluster.")
@click.pass_obj
@click.option("--output", metavar="<tarfile>", default=None,
              help="Location of tar file of host agent files to generate")
@click.option("--rotate/--no-rotate", default=False,
              help="Rotates the host key and certificate. If disabled, the"
                  " command will return the existing key and certificate for"
                  " this host if they already exist.")
@click.option("--verify-token/--no-verify-token", default=False,
              help="Verify the token given on stdin before generating a"
                  " certificate for this hostname.")
@click.argument("hostname", nargs=1, required=True)
@click.argument("altnames", nargs=-1)
def gen_node_cert(ctx_obj, output, hostname, altnames, rotate, verify_token):
  """
  Given a hostname, and optional alternate names, creates a certificate chain,
  valid for this host (and alternate names)
  to use as a TLS server and client. The chain is rooted at the CA that is
  configured to sign certicates for this cluster.

  This command creates a chain as described above and maintains it in the
    certificate repository.

  If "output" is specified, then a .zip file containing the host-specific
    keys, certificate and CA certificate will be generated.
  If the "output" set to "-" will result in the output being directed
    to stdout.
  If output is not specified, this script generates the certificates but does
    not output anything

  The hostname (or IP) we are generating the cert for must be a valid DNS
  name or IPv4 address. This must be the FQDN that is used by CM to identify
  this host.

  \b
  If altnames are specified, they indicate the additional subject alt names
  to add to the certificate. The hostname is added automatically. Multiple
  alternate names may be specified. Each must be in one of the following
  formats:
  1) DNS:<valid-dns-name>
  2) IP:<valid-IPv4-address>
  3) email:<valid-email-address>

  If --verify-token is present, then this command expects a token to be given on
  stdin. The token will be verified using the token signing key before a
  certificate is allowed to be generated for this hostname.
  """
  if verify_token:
    input = sys.stdin.readlines()
    token = "".join(input[0:-1]).strip()
    token_sig = input[-1].strip()
    ctx_obj.certmanager.verify_cert_request_token(token, token_sig, hostname)
    if altnames is not None:
      for altname in altnames:
        ctx_obj.certmanager.verify_cert_request_token(token, token_sig, altname)

  ctx_obj.certmanager.gen_node_cert(output, hostname, altnames, rotate, True)

@certmanager.command(short_help="INTERNAL: Retrieves the certificates and"
                     " truststore for a new node from a directory and adds"
                     " them to the cert database.")
@click.pass_obj
@click.option("--output", metavar="<tarfile>", default="-",
              help="Location of tar file of host agent files to generate")
@click.option("--rotate/--no-rotate", default=False,
              help="Rotates the host key and certificate. This argument is"
              " ignored for this method.")
@click.argument("hostname", nargs=1, required=True)
def copy_node_cert(ctx_obj, output, rotate, hostname):
  """
  Finds the certs corresponding to a hostname from a directory and
  tars them.
  """
  ctx_obj.certmanager.copy_node_cert(output, hostname)

@certmanager.command(short_help="Set the certmanager and the CM server.")
@click.option("--config", metavar="<config-file-or-dir>",
              help="Path for configuration to use. (If a directory, read"
                   " and use all .ini files within it. If a file, must point"
                   " to a config .ini file.)",
              type=click.Path(exists=True, file_okay=True, dir_okay=True,
                              readable=True))
@click.option('--override', metavar="<Section.Property=Value>",
              help="Override config file setting",
              multiple=True, type=click.STRING)
@click.option("--hostname", metavar="<dns-or-ip>",
              help="Alternate name of local host (for SSL certificates)."
              " Only applies if CA type is 'internal'", type=click.STRING)
@click.option("--altname", metavar="<alt-name>", multiple=True,
              help="Alternate name of to add to generated SSL certificates."
                  " Multiple names may be supplied by repeating the option."
                  " Only applies if CA type is 'internal'", type=click.STRING)
@click.option("--write-cm-init/--skip-cm-init",
              help="Writes a CM init file to set Auto-TLS related parameters."
                  " If disabled, only the CA directory will be created, and"
                  " the init file contents will be printed to stdout.",
              default=True)
@click.option("--rotate/--no-rotate",
              help="Rotates the CA keys and certificates. If disabled, the"
                  " command fails if the CA directory already exists.",
              default=False)
@click.option("--configure-services/--no-configure-services",
              help="Configure new services to use Auto-TLS certificates."
                  " If disabled, only agents will use TLS certificates.",
              default=False)
@click.option("--trusted-ca-certs", metavar="<trusted_certs.pem>",
              help="Path to trusted CA certs bundle in PEM format. These"
                  " certs will be imported into the truststore for all hosts.",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--skip-invalid-ca-certs/--fail-invalid-ca-certs",
              help="Whether to skip invalid CA certs in the trusted CA certs"
                  " bundle. If false, setup will fail if any certs are"
                  " invalid or duplicates.",
              default=False)
@click.option("--stop-at-csr/--dont-stop-at-csr",
              help="Whether to stop at signing the CSR. If true, continue the"
              " setup by running setup and passing in --signed-ca-cert.",
              default=False)
@click.option("--signed-ca-cert", metavar="<signed_ca_chain.pem>",
              help="Path to signed CA cert chain. Pass this after running "
              " setup with the --stop-at-csr option.",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.pass_obj
def setup(ctx_obj, config, override, hostname, altname, write_cm_init, rotate,
          configure_services, trusted_ca_certs, skip_invalid_ca_certs,
          stop_at_csr, signed_ca_cert):
  """
  This command initialized the certmanager and setup the certificates for
  the CM server to run on this host, using those certificates.

  The --location option (if any) given to certmanager will decide the
  location of the directory root where the certmanager will keep its files.
  This directory will contain sensitive files. It must be backed up and
  protected accordingly. This directory must not exist prior to calling this
  command, but must be create-able. (i.e. either its ancestors must exist,
  or must be create-able).
  """
  certmanager_dir = ctx_obj.certmanager.certmanager_dir
  marker_file = os.path.join(certmanager_dir, HOST_CSR_MARKER_FILE_NAME)

  if signed_ca_cert:
    # Check that we are at the CSR signing state if a signed cert is given
    if not os.path.exists(marker_file):
      raise Exception("Missing CSR signing marker file. Check that the CMCA "
                      "location '%s' is correct." % certmanager_dir)
  else:
    ctx_obj.certmanager.init_internal_ca(config, override, rotate, stop_at_csr, True)
    if stop_at_csr:
      open(marker_file, 'w').close()
      return

  if hostname is None:
    hostname = socket.gethostname()

  ctx_obj.certmanager.init_truststores(signed_ca_cert)
  ctx_obj.certmanager.import_trusted_ca_certs(trusted_ca_certs,
                                              skip_invalid_ca_certs)
  ctx_obj.certmanager.setup_server_certs(hostname, altname)
  ctx_obj.certmanager.bootstrap_cm_keystores(hostname)
  ctx_obj.certmanager.setup_cm_server(hostname, write_cm_init, configure_services)
  ctx_obj.certmanager.gen_token_signing_key()

  if os.path.exists(marker_file):
    os.unlink(marker_file)

@certmanager.command(short_help="Set up a custom cert directory")
@click.option("--config", metavar="<config-file-or-dir>",
              help="Path for configuration to use. (If a directory, read"
                   " and use all .ini files within it. If a file, must point"
                   " to a config .ini file.)",
              type=click.Path(exists=True, file_okay=True, dir_okay=True,
                              readable=True))
@click.option('--override', metavar="<Section.Property=Value>",
              help="Override config file setting",
              multiple=True, type=click.STRING)
@click.option("--hostname", metavar="<dns-or-ip>",
              help="Alternate name of local host (for SSL certificates).",
              type=click.STRING)
@click.option("--host-cert", metavar="<file>",
              help="Path to CM host's certificate",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--host-key", metavar="<file>",
              help="Path to CM host's key",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--ca-cert", metavar="<file>",
              help="Path to in-cluster CA certificate",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--keystore-pw-file", metavar="<file>",
              help="Path to password file used by all keystores",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--truststore-pw-file", metavar="<file>",
              help="Path to password file used by all truststores",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--write-cm-init/--skip-cm-init",
              help="Writes a CM init file to set Auto-TLS related parameters."
                  " If disabled, only the CA directory will be initialized, and"
                  " the init file contents will be printed to stdout.",
              default=True)
@click.option("--configure-services/--no-configure-services",
              help="Configure new services to use Auto-TLS certificates."
                  " If disabled, only agents will use TLS certificates.",
              default=False)
@click.option("--trusted-ca-certs", metavar="<trusted_certs.pem>",
              help="Path to trusted CA certs bundle in PEM format. These"
                  " certs will be imported into the truststore for all hosts.",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--skip-invalid-ca-certs/--fail-invalid-ca-certs",
              help="Whether to skip invalid CA certs in the trusted CA certs"
                  " bundle. If false, setup will fail if any certs are"
                  " invalid or duplicates.",
              default=False)
@click.pass_obj
def setup_custom_certdir(ctx_obj, config, override, hostname, host_cert,
                         host_key, ca_cert, keystore_pw_file,
                         truststore_pw_file, write_cm_init,
                         configure_services, trusted_ca_certs,
                         skip_invalid_ca_certs):
  """
  This command initializes the certmanager using a custom cert directory.

  The --location option must be given to certmanager and determines the root
  folder containing all the host certificates.

  The folder must follow the following structure:

  - root dir
    - trust-store
      - cm-auto-in_cluster_ca_cert.pem (CA cert)
    - hosts-key-store
      - host1
        - cm-auto-host_key.pem (host key)
        - cm-auto-host_cert_chain.pem (host cert)
      - host2
        - etc.

  As a convenience, the host-cert, host-key, and ca-cert options will write
  the corresponding files to the correct locations. Otherwise, they must exist
  before running this command.

  CM will generate missing files such as JKS versions of PEM files and password
  files. If a password is not given as a command line option, this command will
  prompt for it on stdin.
  """
  keystore_password = ""
  if keystore_pw_file:
    with open(keystore_pw_file) as f:
      keystore_password = f.read().strip()
  else:
    keystore_password = getpass("Enter the password used for all keystores: ")

  truststore = ""
  if truststore_pw_file:
    with open(truststore_pw_file) as f:
      truststore_password = f.read().strip()
  else:
    truststore_password = getpass("Enter the password used for all truststores: ")

  if hostname is None:
    hostname = socket.gethostname()

  ctx_obj.certmanager.setup_config(config, override, True)
  ctx_obj.certmanager.init_custom_certdir(hostname, host_cert, host_key, ca_cert)
  ctx_obj.certmanager.setup_server_with_custom_certs(hostname, keystore_password,
                                                     truststore_password)
  ctx_obj.certmanager.import_trusted_ca_certs(trusted_ca_certs,
                                              skip_invalid_ca_certs)
  ctx_obj.certmanager.bootstrap_cm_keystores(hostname)
  ctx_obj.certmanager.setup_cm_server(hostname, write_cm_init, configure_services)
  ctx_obj.certmanager.gen_token_signing_key()

@dev_tools.command(short_help="Initialize the internal CA")
@click.option("--config", metavar="<config-file-or-dir>",
              help="Path for configuration to use. (If a directory, read"
                   " and use all .ini files within it. If a file, must point"
                   " to a config .ini file.)",
              type=click.Path(exists=True, file_okay=True, dir_okay=True,
                              readable=True))
@click.option('--override', metavar="<Section.Property=Value>",
              help="Override config file setting",
              multiple=True, type=click.STRING)
@click.option("--rotate/--no-rotate",
              help="Rotates the CA keys and certificates. If disabled, the"
                  " command fails if the CA directory already exists.",
              default=False)
@click.pass_obj
def init_internal_ca(ctx_obj, config, override, rotate):
  """
  This command is only meant to be used by Dev/Test. Do not use directly.

  Initialize the internal CA using the config params.

  Can only be called when the CA type is internal. Do not
  call more than once.
  """
  ctx_obj.certmanager.init_internal_ca(config, override, rotate, False, True)
  ctx_obj.certmanager.init_truststores()
  ctx_obj.certmanager.import_trusted_ca_certs()

@dev_tools.command(short_help="Configure the local SCM server for TLS")
@click.pass_obj
@click.option("--hostname", metavar="<dns-or-ip>",
              help="Alternate name of local host (for SSL certificates)."
                   " Only applies if CA type is 'internal'",
              type=click.STRING)
@click.option("--altname", metavar="<alt-name>", multiple=True,
              help="Alternate name of to add to generated SSL certificates."
                   " Multiple names may be supplied by repeating the option."
                   " Only applies if CA type is 'internal'",
              type=click.STRING)
def setup_server_certs(ctx_obj, hostname, altname):
  """
  This command is only meant to be used by Dev/Test. Do not use directly.

  Configures the CM server for this host.
  """
  ctx_obj.certmanager.setup_server_certs(hostname, altname)


@dev_tools.command(short_help="Configure the local SCM agent for TLS")
@click.pass_obj
@click.argument("tarfile", nargs=1, required=True,
                type=click.Path(exists=True, file_okay=True,
                                dir_okay=False, readable=True))
@click.argument("agent_cert_dir", nargs=1, required=False,
                default=DEFAULT_AGENT_CERTS_DIR)
@click.argument("agent_conf_file", nargs=1, required=False,
                default=DEFAULT_AGENT_CONFIG_FILE)
def setup_agent_certs(ctx_obj, tarfile, agent_cert_dir, agent_conf_file):
  ctx_obj.certmanager.setup_agent_certs(tarfile, agent_cert_dir,
                                        agent_conf_file)

@certmanager.command(short_help="Dump the internal CA's certificate.")
@click.pass_obj
def export_ca_cert(ctx_obj):
  """
  When the CA is of type "internal", this command dumps
  out the root CA certificate in PEM format to stdout.
  It is an error to use this command when the CA type is
  other than "internal"
  """
  ctx_obj.certmanager.export_ca_cert()

@certmanager.command(short_help="Add a custom key/cert for a host. Use only if "
                     "a custom cert directory is configured. This command must "
                     "be run before adding a host or running the "
                     "GenerateHostCerts command.")
@click.option("--host-cert", metavar="<file>",
              help="Path to CM host's certificate",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--host-key", metavar="<file>",
              help="Path to CM host's key",
              type=click.Path(exists=True, file_okay=True, dir_okay=False,
                              readable=True))
@click.option("--output", metavar="<tarfile>", default=None,
              help="Location of tar file of host agent files to generate")
@click.argument("hostname", nargs=1, required=True)
@click.pass_obj
def add_custom_cert(ctx_obj, host_cert, host_key, output, hostname):
  """
  This command adds a custom key/cert for a host to the custom certdir.

  The --location option must be given to certmanager and determines the root
  folder containing all the host certificates.

  CM will generate missing files such as JKS versions of PEM files and password
  files.

  This command must be run before adding a host or running the GenerateHostCerts
  command on an existing host.
  """
  if not hostname or not host_cert or not host_key:
    raise Exception("Must specify hostname, host-cert, and host-key")

  if not os.path.isdir(ctx_obj.certmanager.certmanager_dir):
    raise Exception("Certmanager path '%s' does not exist" %
                    ctx_obj.certmanager.certmanager_dir)

  ctx_obj.certmanager.add_custom_cert(hostname, host_cert, host_key)
  ctx_obj.certmanager.copy_node_cert(output, hostname)

@certmanager.command(short_help="Generate a certificate request token that can "
                     "exchanged for a certificate.")
@click.pass_obj
@click.option("--output", metavar="<filename>", required=True,
              help="Filename to write token into")
@click.option("--hostname", metavar="<hostname>",
              help="The hostname which must match the certificate hostname")
@click.option("--hostname-pattern", metavar="<regex>",
              help="A regex which must match the certificate hostname")
@click.option("--lifetime", metavar="<duration-secs>", required=True,
              type=click.INT,
              help="Token lifetime in seconds from now, or unlimited if 0")
def gen_cert_request_token(ctx_obj, output, hostname, hostname_pattern, lifetime):
  """
  Given an output filename, hostname, and a validity lifetime, generates a
  certificate request token that can be presented by a host to exchange for a
  valid certificate.
  """
  if not hostname and not hostname_pattern:
    raise Exception("Must specify either hostname or hostname_pattern")

  if hostname and hostname_pattern:
    raise Exception("Only one of hostname or hostname_pattern is allowed")

  ctx_obj.certmanager.gen_cert_request_token(output, hostname, hostname_pattern,
                                             lifetime)

def main():
  if len(sys.argv)>1 and sys.argv[1]=="--dev":
    del sys.argv[1]
    return dev_tools(obj=argparse.Namespace())
  else:
    return certmanager(obj=argparse.Namespace())

if __name__ == "__main__":
  sys.exit(main())
